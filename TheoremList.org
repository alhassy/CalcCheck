#+title: Theorem List
#+subtitle: [[https://alhassy.github.io/CalcCheck/][Mathematics for Computing, CS/SE 2DM3, Fall 2020]]
#+author: Musa Al-hassy and Wolfram Kahl
#+options: tags:t d:nil toc:t
#+PROPERTY: header-args:calccheck :tangle (concat (file-name-sans-extension (buffer-name)) ".calc") :comments nil

#+Description: List of theorems introduced in McMaster's 2DM3 in the fall of 2020.

#+HTML_HEAD: <link href="https://alhassy.github.io/org-notes-style.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://alhassy.github.io/floating-toc.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://alhassy.github.io/blog-banner.css" rel="stylesheet" type="text/css" />
# The last one has the styling for lists.

#+begin_center
#+include: ~/Desktop/colours_palette.html export html
#+end_center

#+name: startup-code
#+begin_src emacs-lisp :exports none
(require 'cl)
(load-file "~/Desktop/power-blocks.el")
#+end_src

#+BEGIN_export html
<style>

/* Show source blocks â€œhaskellâ€ differnetly */
pre.src-haskell:before { content: 'Mathematical! Algebraic! Axiomatic!'; }
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell)) */

</style>
#+END_export

# Get all files as org trees
#+begin_src emacs-lisp :results replace output raw :exports none
(loop for c in (--filter (and (s-ends-with? ".calc" it) (not (s-contains? "SOL" it))) (f-files "~/2DM3-2020/CalcCheckNotebooks/Week10" (lambda (f) t) t))
      for contents = (with-temp-buffer
                       (insert-file-contents c)
                       (buffer-string))
      do (princ (s-concat "\n\n\n** " (f-base c)
                   "\n#+begin_src haskell\n"
                   contents
                   "\n#+end_src"
                   )))
#+end_src

* Inequality
  :PROPERTIES:
  :CUSTOM_ID: Inequality
  :END:

Inequality is defined as negation of equality.
#+begin_src haskell
Declaration: _â‰ _ : t â†’ t â†’ ğ”¹

Axiom â€œDefinition of â‰ â€: x â‰  y  â‰¡  Â¬ (x = y)
#+end_src

It is convenient to have irreflexivity of inequality available in two (equivalent) shapes:
#+begin_src haskell
Theorem â€œIrreflexivity of â‰ â€: Â¬ (x â‰  x)

Theorem â€œIrreflexivity of â‰ â€: x â‰  x  â‰¡  false
#+end_src

Inequality is symmetric (but, unlike equality, not transitive):
#+begin_src haskell
Theorem â€œSymmetry of â‰ â€:  x â‰  y  â‰¡  y â‰  x
#+end_src

* Equational Theory of Integers :Exercise_2:
  :PROPERTIES:
  :CUSTOM_ID: Equational-Theory-of-Integers
  :END:

  Here we develop that part of LADM's â€œTheory of Integersâ€ that only requires
  equational reasoning *on the integers only*, with no other logical symbols
  besides ~=~, not even ~â‰¡~.

  #+begin_src haskell
Declaration: _+_ : â„¤ â†’ â„¤ â†’ â„¤
Declaration: _Â·_ : â„¤ â†’ â„¤ â†’ â„¤

Axiom (15.1) (15.1a) â€œAssociativity of +â€: (a + b) + c = a + (b + c)
Axiom (15.1) (15.1b) â€œAssociativity of Â·â€: (a Â· b) Â· c = a Â· (b Â· c)
Axiom (15.2) (15.2a) â€œSymmetry of +â€: a + b = b + a
Axiom (15.2) (15.2b) â€œSymmetry of Â·â€: a Â· b = b Â· a

Axiom (15.3) â€œAdditive identityâ€ â€œIdentity of +â€: 0 + a = a
Axiom (15.4) â€œMultiplicative identityâ€ â€œIdentity of Â·â€: 1 Â· a = a
Axiom (15.5) â€œDistributivityâ€ â€œDistributivity of Â· over +â€: a Â· (b + c) = a Â· b + a Â· c
Axiom (15.9) â€œZero of Â·â€: a Â· 0 = 0

Declaration: -_ : â„¤ â†’ â„¤
Declaration: _-_ : â„¤ â†’ â„¤ â†’ â„¤

Axiom (15.13) â€œUnary minusâ€: a + (- a) = 0
Axiom (15.14) â€œSubtractionâ€: a - b = a + (- b)


Theorem (15.17) â€œSelf-inverse of unary minusâ€:
   - (- a) = a

Theorem (15.18) â€œFixpoint of unary minusâ€: - 0 = 0

Theorem (15.20): - a = (- 1) Â· a

Theorem (15.19) â€œDistributivity of unary minus over +â€:
    - (a + b) = (- a) + (- b)

Theorem (15.21): (- a) Â· b = a Â· (- b)

Theorem (15.22): a Â· (- b) = - (a Â· b)

Theorem (15.23): (- a) Â· (- b) = a Â· b

Theorem (15.24) â€œRight-identity of -â€: a - 0 = a

Theorem (15.25): (a - b) + (c - d) = (a + c) - (b + d)

Theorem (15.26): (a - b) - (c - d) = (a + d) - (b + c)

Theorem (15.27): (a - b) Â· (c - d) = (a Â· c + b Â· d) - (a Â· d + b Â· c)

Theorem (15.29) â€œDistributivity of Â· over -â€:
    (a - b) Â· c = a Â· c - b Â· c

#+end_src

* Propositional Calculus
  :PROPERTIES:
  :CUSTOM_ID: Propositional-Calculus
  :END:
** Conjunction                                                 :Exercise:3_3:
   :PROPERTIES:
   :CUSTOM_ID: Conjunction
   :END:
 #+begin_src haskell
Declaration: _âˆ§_ : ğ”¹ â†’ ğ”¹ â†’ ğ”¹

Axiom (3.35) â€œGolden ruleâ€: p âˆ§ q â‰¡ p â‰¡ q â‰¡ p âˆ¨ q

Theorem (3.36) â€œSymmetry of âˆ§â€: p âˆ§ q â‰¡ q âˆ§ p

Theorem (3.37) â€œAssociativity of âˆ§â€: (p âˆ§ q) âˆ§ r â‰¡ p âˆ§ (q âˆ§ r)

Theorem (3.38) â€œIdempotency of âˆ§â€: p âˆ§ p â‰¡ p

Theorem (3.39) â€œIdentity of âˆ§â€: p âˆ§ true â‰¡ p

Theorem (3.40) â€œZero of âˆ§â€: p âˆ§ false â‰¡ false

Theorem (3.41) â€œDistributivity of âˆ§ over âˆ§â€: p âˆ§ (q âˆ§ r) â‰¡ (p âˆ§ q) âˆ§ (p âˆ§ r)

Theorem (3.42) â€œContradictionâ€: p âˆ§ Â¬ p â‰¡ false

Theorem (3.43) (3.43a) â€œAbsorptionâ€: p âˆ§ (p âˆ¨ q) â‰¡ p

Theorem (3.43) (3.43b) â€œAbsorptionâ€: p âˆ¨ (p âˆ§ q) â‰¡ p

Theorem (3.44) (3.44a) â€œAbsorptionâ€: p âˆ§ (Â¬ p âˆ¨ q) â‰¡ p âˆ§ q

Theorem (3.44) (3.44b) â€œAbsorptionâ€: p âˆ¨ (Â¬ p âˆ§ q) â‰¡ p âˆ¨ q

Theorem (3.44) (3.44c) â€œAbsorptionâ€: Â¬ p âˆ§ (p âˆ¨ q) â‰¡ Â¬ p âˆ§ q

Theorem (3.44) (3.44d) â€œAbsorptionâ€: Â¬ p âˆ¨ (p âˆ§ q) â‰¡ Â¬ p âˆ¨ q

Theorem (3.45) â€œDistributivity of âˆ¨ over âˆ§â€: p âˆ¨ (q âˆ§ r) â‰¡ (p âˆ¨ q) âˆ§ (p âˆ¨ r)

Theorem (3.46) â€œDistributivity of âˆ§ over âˆ¨â€: p âˆ§ (q âˆ¨ r) â‰¡ (p âˆ§ q) âˆ¨ (p âˆ§ r)

Theorem (3.47) (3.47a) â€œDe Morganâ€: Â¬(p âˆ§ q) â‰¡ Â¬ p âˆ¨ Â¬ q

Theorem (3.47) (3.47b) â€œDe Morganâ€: Â¬(p âˆ¨ q) â‰¡ Â¬ p âˆ§ Â¬ q

Theorem (3.48): p âˆ§ q â‰¡ p âˆ§ Â¬ q â‰¡ Â¬ p

Theorem (3.49) â€œSemi-distributivity of âˆ§ over â‰¡â€: p âˆ§ (q â‰¡ r) â‰¡ p âˆ§ q â‰¡ p âˆ§ r â‰¡ p

Theorem (3.50) â€œStrong Modus Ponensâ€: p âˆ§ (q â‰¡ p) â‰¡ p âˆ§ q

Theorem (3.51) â€œReplacementâ€: (p â‰¡ q) âˆ§ (r â‰¡ p) â‰¡ (p â‰¡ q) âˆ§ (r â‰¡ q)

Theorem (3.52) â€œAlternative definition of â‰¡â€: p â‰¡ q â‰¡ (p âˆ§ q) âˆ¨ (Â¬ p âˆ§ Â¬ q)

Theorem (3.53) â€œExclusive orâ€ â€œAlternative definition of â‰¢â€:
  (p â‰¢ q) â‰¡ (Â¬ p âˆ§ q) âˆ¨ (p âˆ§ Â¬ q)

Theorem (3.55): (p âˆ§ q) âˆ§ r â‰¡ p â‰¡ q â‰¡ r â‰¡ p âˆ¨ q â‰¡ q âˆ¨ r â‰¡ r âˆ¨ p â‰¡ p âˆ¨ q âˆ¨ r
 #+end_src

** Disjunction                                    :Exercise_3_2:Homework_5_2:
   :PROPERTIES:
   :CUSTOM_ID: Disjunction
   :END:
 #+begin_src haskell
Declaration: _âˆ¨_ : ğ”¹ â†’ ğ”¹ â†’ ğ”¹

Axiom (3.24) â€œSymmetry of âˆ¨â€: p âˆ¨ q â‰¡ q âˆ¨ p

Axiom (3.25) â€œAssociativity of âˆ¨â€: (p âˆ¨ q) âˆ¨ r â‰¡ p âˆ¨ (q âˆ¨ r)

Axiom (3.26) â€œIdempotency of âˆ¨â€: p âˆ¨ p â‰¡ p

Axiom (3.27) â€œDistributivity of âˆ¨ over â‰¡â€: p âˆ¨ (q â‰¡ r) â‰¡ p âˆ¨ q â‰¡ p âˆ¨ r

Axiom (3.28) â€œExcluded Middleâ€ â€œLEMâ€: p âˆ¨ Â¬ p

Theorem (3.29) â€œZero of âˆ¨â€: p âˆ¨ true â‰¡ true

Theorem (3.30) â€œIdentity of âˆ¨â€: p âˆ¨ false â‰¡ p

Theorem (3.31) â€œDistributivity of âˆ¨ over âˆ¨â€: p âˆ¨ (q âˆ¨ r) â‰¡ (p âˆ¨ q) âˆ¨ (p âˆ¨ r)

Theorem (3.32): p âˆ¨ q â‰¡ p âˆ¨ Â¬ q â‰¡ p
 #+end_src

** Formalising â€œKnights and Knavesâ€ Puzzles                    :Exercise_3_1:
   :PROPERTIES:
   :CUSTOM_ID: Formalising-Knights-and-Knaves-Puzzles
   :END:

   Raymond Smullyan posed many puzzles about an island that has two kinds of inhabitants:

   * knights, who always tell the truth, and
   * knaves, who always lie.

   You encounter two people A and B.

   The above paragraph contains information that is common to all scenarios below.

   We are careful to postulate as axioms only statements that apply in all scenarios.

   We declare a special type for the inhabitants of that island:
 #+begin_src haskell
Declaration: Inhabitant : Type
Declaration: _is-knight, _is-knave : Inhabitant â†’ ğ”¹
 #+end_src

   We then encode the two kinds of inhabitants as two unary Boolean-valued predicate operators,
   written in postfix syntax, and given higher precedence than logical negation,
   so we can write ~Â¬ X is-knight~ with the same meaning as ~Â¬ (X is-knight)~:

   Obviously the â€œtwo kinds of inhabitantsâ€ are intended to be exhaustive;
   we formalise that as an inequivalence, and derive alternative formualations
   that well be useful for reasoning below:
 #+begin_src haskell
Axiom â€œKnights and knavesâ€: X is-knight â‰¢ X is-knave

Lemma â€œKnights and knavesâ€: X is-knight â‰¡ Â¬ X is-knave

Lemma â€œKnights and knavesâ€: X is-knave â‰¡ Â¬ X is-knight
 #+end_src

   The puzzles are all presented as stories contining as key ingredients
   that some inhabitant ~X~ makes some statement ~s~;
   if we formalise that statement ~s~ into proposition ~p~,
   then we formalist that whole ingredient as:

 #+begin_src haskell
    X says-ğŸ™¶ p ğŸ™·
 #+end_src

   The extra-fat quotation marks in ~_says-ğŸ™¶_ğŸ™·~ are obtained by typing ~\```~
   respectively ~\'''~.

 #+begin_src haskell
Precedence 140 for:  _says-ğŸ™¶_ğŸ™·
Declaration: _says-ğŸ™¶_ğŸ™· : Inhabitant â†’ ğ”¹ â†’ ğ”¹
 #+end_src

 The definitions of knights and knaves are the easily formalised:
 #+begin_src haskell
Axiom â€œKnighthoodâ€: X says-ğŸ™¶ p ğŸ™· â‰¡ X is-knight â‰¡ p
Axiom â€œKnavehoodâ€:  X says-ğŸ™¶ p ğŸ™· â‰¡ X is-knave  â‰¡ Â¬ p
 #+end_src

   Finally, we formalise the statement â€œYou encounter two people A and Bâ€,
   making explicit the assumptions that these â€œpeopleâ€ are inhabitants of this island.
 #+begin_src haskell
Declaration: A, B : Inhabitant
 #+end_src

** Leibniz's Rule as an Axiom, Replacement Theorems :Exercise:5_1:Homework:7_2:
   :PROPERTIES:
   :CUSTOM_ID: Leibniz's-Rule-as-an-Axiom-Replacement-Theorems
   :END:
 #+begin_src haskell
Theorem â€œDefinition of â‰¡â€:  (p â‰¡ q) = (p = q)

Axiom (3.83) â€œLeibnizâ€: e = f â‡’ E[z â‰” e] = E[z â‰” f]

Theorem (3.84) (3.84a) â€œReplacementâ€:
    (e = f) âˆ§ E[z â‰” e] â‰¡ (e = f) âˆ§ E[z â‰” f]

Theorem (3.84) (3.84b) â€œReplacementâ€:
    (e = f) â‡’ E[z â‰” e] â‰¡ (e = f) â‡’ E[z â‰” f]

Theorem (3.84) (3.84c) â€œReplacementâ€:
    q âˆ§ (e = f) â‡’ E[z â‰” e] â‰¡ q âˆ§ (e = f) â‡’ E[z â‰” f]

Theorem (3.85) (3.85a) â€œReplace by `true`â€: p â‡’ E[z â‰” p] â‰¡ p â‡’ E[z â‰” true]

Theorem (3.85) (3.85b) â€œReplace by `true`â€: q âˆ§ p â‡’ E[z â‰” p] â‰¡ q âˆ§ p â‡’ E[z â‰” true]

Theorem (3.85c) â€œReplace by `false`â€: Â¬ p â‡’ E[z â‰” p] â‰¡ Â¬ p â‡’ E[z â‰” false]

Theorem (3.86) (3.86a) â€œReplace by `false`â€: E[z â‰” p] â‡’ p â‰¡ E[z â‰” false] â‡’ p

Theorem (3.86) (3.86b) â€œReplace by `false`â€: E[z â‰” p] â‡’ p âˆ¨ q â‰¡ E[z â‰” false] â‡’ p âˆ¨ q

Theorem (3.87) â€œReplace by `true`â€: p âˆ§ E[z â‰” p] â‰¡ p âˆ§ E[z â‰” true]

Theorem (3.88) â€œReplace by `false`â€: p âˆ¨ E[z â‰” p] â‰¡ p âˆ¨ E[z â‰” false]

Theorem (3.89) â€œShannonâ€: E[z â‰” p] â‰¡ (p âˆ§ E[z â‰” true]) âˆ¨ (Â¬ p âˆ§ E[z â‰” false])

 #+end_src
 # 7.2
   #+begin_src haskell
Axiom (3.83) â€œLeibnizâ€: e = f  â‡’  E[z â‰” e] = E[z â‰” f]

Theorem (3.84) (3.84a) â€œReplacementâ€:
    (e = f) âˆ§ E[z â‰” e]  â‰¡  (e = f) âˆ§ E[z â‰” f]

Lemma â€œReplacement in equality with additionâ€:
    a = b + c âˆ§ c = d  â‰¡  a = b + d âˆ§ c = d
 #+end_src

** Implication                                   :Exercise:4_1::Homework:7_1:
   :PROPERTIES:
   :CUSTOM_ID: Implication
   :END:
 #+begin_src haskell
Declaration: _â‡’_ : ğ”¹ â†’ ğ”¹ â†’ ğ”¹

Declaration: _â‡_ : ğ”¹ â†’ ğ”¹ â†’ ğ”¹

Axiom (3.57) â€œDefinition of â‡’â€: p â‡’ q â‰¡ p âˆ¨ q â‰¡ q

Axiom (3.58) â€œConsequenceâ€ â€œDefinition of â‡â€: p â‡ q â‰¡ q â‡’ p

Theorem (3.59) â€œDefinition of â‡’â€: p â‡’ q â‰¡ Â¬ p âˆ¨ q

Theorem (3.60) â€œDefinition of â‡’â€: p â‡’ q â‰¡ p âˆ§ q â‰¡ p

Theorem (3.61) â€œContrapositiveâ€: p â‡’ q â‰¡ Â¬ q â‡’ Â¬ p

Theorem (3.62): p â‡’ (q â‰¡ r) â‰¡ p âˆ§ q â‰¡ p âˆ§ r

Theorem (3.63) â€œDistributivity of â‡’ over â‰¡â€: p â‡’ (q â‰¡ r) â‰¡ p â‡’ q â‰¡ p â‡’ r

Theorem (3.64): p â‡’ (q â‡’ r) â‰¡ (p â‡’ q) â‡’ (p â‡’ r)

Theorem (3.65) â€œShuntingâ€: p âˆ§ q â‡’ r â‰¡ p â‡’ (q â‡’ r)

Theorem (3.66): p âˆ§ (p â‡’ q) â‰¡ p âˆ§ q

Theorem (3.67): p âˆ§ (q â‡’ p) â‰¡ p

Theorem (3.68): p âˆ¨ (p â‡’ q) â‰¡ true

Theorem (3.69): p âˆ¨ (q â‡’ p) â‰¡ q â‡’ p

Theorem (3.70): p âˆ¨ q â‡’ p âˆ§ q â‰¡ p â‰¡ q

Theorem (3.71) â€œReflexivity of â‡’â€: (p â‡’ p) â‰¡ true

Theorem (3.72) â€œRight zero of â‡’â€: (p â‡’ true) â‰¡ true

Theorem (3.73) â€œLeft identity of â‡’â€: (true â‡’ p) â‰¡ p

Theorem (3.74) â€œDefinition of Â¬ from â‡’â€: (p â‡’ false) â‰¡ Â¬ p

Theorem (3.75) â€œex falso quodlibetâ€: (false â‡’ p) â‰¡ true

Theorem (3.76) (3.76a) â€œWeakeningâ€ â€œStrengtheningâ€: p â‡’ p âˆ¨ q

Theorem (3.76) (3.76a) â€œWeakeningâ€ â€œStrengtheningâ€: p â‡’ p âˆ¨ q

Theorem (3.76) (3.76b) â€œWeakeningâ€ â€œStrengtheningâ€: p âˆ§ q â‡’ p

Theorem (3.76) (3.76c) â€œWeakeningâ€ â€œStrengtheningâ€: p âˆ§ q â‡’ p âˆ¨ q

Theorem (3.76) (3.76d) â€œWeakeningâ€ â€œStrengtheningâ€: p âˆ¨ (q âˆ§ r) â‡’ p âˆ¨ q

Theorem (3.76) (3.76e) â€œWeakeningâ€ â€œStrengtheningâ€: p âˆ§ q â‡’ p âˆ§ (q âˆ¨ r)

Theorem (3.77) â€œModus ponensâ€: p âˆ§ (p â‡’ q) â‡’ q

Theorem (3.78): (p â‡’ r) âˆ§ (q â‡’ r) â‰¡ (p âˆ¨ q â‡’ r)

Theorem (3.79): (p â‡’ r) âˆ§ (Â¬ p â‡’ r) â‰¡ r

Theorem (3.80) â€œMutual implicationâ€: (p â‡’ q) âˆ§ (q â‡’ p) â‰¡ p â‰¡ q

Theorem (3.81) â€œAntisymmetry of â‡’â€: (p â‡’ q) âˆ§ (q â‡’ p) â‰¡ (p â‰¡ q)

Theorem (3.82) (3.82a) â€œTransitivity of â‡’â€: (p â‡’ q) âˆ§ (q â‡’ r) â‡’ (p â‡’ r)

Theorem (3.82) (3.82b) â€œTransitivity of â‡’â€: (p â‰¡ q) âˆ§ (q â‡’ r) â‡’ (p â‡’ r)

Theorem (3.82) (3.82c) â€œTransitivity of â‡’â€: (p â‡’ q) âˆ§ (q â‰¡ r) â‡’ (p â‡’ r)
 #+end_src


 # 7.1
 #+begin_src haskell

Theorem (3.59) â€œMaterial implicationâ€: p â‡’ q â‰¡ Â¬ p âˆ¨ q

Theorem (3.65) â€œShuntingâ€: p âˆ§ q â‡’ r â‰¡ p â‡’ (q â‡’ r)

Theorem (3.66) â€œStrong modus ponensâ€: p âˆ§ (p â‡’ q) â‰¡ p âˆ§ q

Theorem (3.67) â€œEven ifâ€: p âˆ§ (q â‡’ p) â‰¡ p

Theorem (3.71) â€œReflexivity of â‡’â€: p â‡’ p

Theorem â€œIndirect reflexivity of â‡’â€: (p â‰¡ q) â‡’ (p â‡’ q)

Theorem (3.80) â€œMutual implicationâ€: (p â‡’ q) âˆ§ (q â‡’ p) â‰¡ p â‰¡ q

Theorem (3.81) â€œAntisymmetry of â‡’â€: (p â‡’ q) âˆ§ (q â‡’ p) â‡’ (p â‰¡ q)

Theorem (3.82) (3.82a) â€œTransitivity of â‡’â€: (p â‡’ q) âˆ§ (q â‡’ r) â‡’ (p â‡’ r)

Theorem (3.82) (3.82b) â€œTransitivity of â‡’â€: (p â‰¡ q) âˆ§ (q â‡’ r) â‡’ (p â‡’ r)

Theorem â€œAntitonicity of Â¬â€:  (p â‡’ q) â‡’ (Â¬ q â‡’ Â¬ p)

Theorem â€œLeft-monotonicity of âˆ¨â€: (p â‡’ q) â‡’ ((p âˆ¨ r) â‡’ (q âˆ¨ r))

Theorem â€œLeft-monotonicity of âˆ§â€: (p â‡’ q) â‡’ ((p âˆ§ r) â‡’ (q âˆ§ r))

Theorem â€œLeft-antitonicity of â‡’â€: (p â‡’ q) â‡’ ((q â‡’ r) â‡’ (p â‡’ r))

Theorem â€œRight-monotonicity of â‡’â€: (p â‡’ q) â‡’ ((r â‡’ p) â‡’ (r â‡’ q))
 #+end_src

** Conditionals                                                :Homework:9_2:
   :PROPERTIES:
   :CUSTOM_ID: Conditionals
   :END:

 #+begin_src haskell
Declaration: if_then_else_fi : ğ”¹ â†’ t â†’ t â†’ t

Axiom â€œif trueâ€:   if true  then x else y fi  =  x
Axiom â€œif falseâ€:  if false then x else y fi  =  y

Theorem â€œ`if` to âˆ¨â€:
    P[z â‰” if b then x else y fi]
  â‰¡ (b âˆ§ P[z â‰” x]) âˆ¨ (Â¬ b âˆ§ P[z â‰” y])

Theorem â€œif swapâ€:
      if   b then x else y fi
   =  if Â¬ b then y else x fi

Theorem â€œif then=trueâ€: if R then true else P fi   â‰¡  R âˆ¨ P

Theorem â€œif else=falseâ€: if R then P else false fi   â‰¡  R âˆ§ P
 #+end_src

* Abstract Algebra: Magmas, Monoids, and Groups :Assignment:1:
  :PROPERTIES:
  :CUSTOM_ID: Abstract-Algebra-Magmas-Monoids-and-Groups
  :END:

** Basics
   :PROPERTIES:
   :CUSTOM_ID: Basics
   :END:
#+begin_src haskell
Theorem â€œA Boolean expression not equal to true is equal to falseâ€:
   (p â‰¢ true) â‰¡ (p â‰¡ false)

Declaration: even : â„¤ â†’ ğ”¹

Axiom â€œEven distributes over +â€: even (x + y) â‰¡ even x â‰¡ even y
Axiom â€œEven of 2â€: even 2
Axiom â€œEven of 1 ---not!â€: Â¬ even 1

Declaration: black : â„¤ â†’ â„¤ â†’ ğ”¹

Axiom â€œDefinition of blackâ€:  black i j â‰¡ even i â‰¡ even j

Theorem â€œBishops stay on the same colourâ€:
    black (i + k) (j + k) â‰¡ black i j

Theorem â€œKnights always change coloursâ€: black (i + 2) (j + 1) â‰¢ black i j
#+end_src

** Recalling Magmas
   :PROPERTIES:
   :CUSTOM_ID: Recalling-Magmas
   :END:
#+begin_src haskell
Declaration: Ï„ : Type
Declaration: _âŠ•_ : Ï„ â†’ Ï„ â†’ Ï„

Axiom â€œAssociativity of âŠ•â€: (x âŠ• y) âŠ• z = x âŠ• (y âŠ• z)

Theorem â€œAssociativity of â‰¢â€:
     ((p â‰¢ q) â‰¢ r) = (p â‰¢ (q â‰¢ r))
#+end_src
** Monoid Madness
   :PROPERTIES:
   :CUSTOM_ID: Monoid-Madness
   :END:
#+begin_src haskell
Declaration: Id : Ï„
Axiom â€œLeft-identity of âŠ•â€: x = Id âŠ• x

Theorem â€œLeft-identity of â‰¢â€: (false â‰¢ p) â‰¡ p

Axiom â€œSymmetry of âŠ•â€:  x âŠ• y = y âŠ• x

Theorem â€œSymmetry of â‰¢â€:  (p â‰¢ q) â‰¡ (q â‰¢ p)

Theorem â€œRight-identity of âŠ•â€:  x = x âŠ• Id
#+end_src
** â€œEveryone break into Groups!â€
   :PROPERTIES:
   :CUSTOM_ID: Everyone-break-into-Groups
   :END:
#+begin_src haskell
Precedence 210 for: inv_
Declaration: inv_ : Ï„ â†’ Ï„
Axiom â€œLeft-inversesâ€: inv x âŠ• x = Id

Theorem â€œRight-inversesâ€: x âŠ• inv x = Id

Theorem â€œLeft-inverses for â‰¢â€: (p â‰¢ p) = false

Precedence 190 for: _âŠ_   -- entered with `\o-` and `\ominus`.
Declaration: _âŠ_ : Ï„ â†’ Ï„ â†’ Ï„

Axiom â€œDefinition of âŠâ€: x âŠ y = x âŠ• inv y

Theorem â€œMutual associativity of âŠ• and âŠâ€:
    x âŠ• (y âŠ z) = (x âŠ• y) âŠ z

Theorem â€œRight-identity of inverseâ€: x âŠ Id = x

Theorem â€œSelf-cancellation of inverseâ€: x âŠ x = Id

Theorem â€œInverse of compositionâ€ â€œSubtraction of sumâ€:
    x âŠ (y âŠ• z) = (x âŠ z) âŠ y
#+end_src
** Relative Undoability: Uniqueness of ï¼Binary Inversesï¼¼
   :PROPERTIES:
   :CUSTOM_ID: Relative-Undoability-Uniqueness-of-Binary-Inverses
   :END:
#+begin_src haskell
Declaration: _ï¼_ : Ï„ â†’ Ï„ â†’ Ï„
Declaration: _ï¼¼_ : Ï„ â†’ Ï„ â†’ Ï„

Axiom â€œUnderâ€: x âŠ• y = z  â‰¡  y = x ï¼¼ z
Axiom â€œOverâ€:  x âŠ• y = z  â‰¡  x = z ï¼ y

Theorem â€œUnder with âŠ• in the numeratorâ€:    y = x ï¼¼ (x âŠ• y)

Theorem â€œâŠ• then Underâ€:                     x âŠ• (x ï¼¼ z) = z

Theorem â€œOver with âŠ• in the numeratorâ€:     x = (x âŠ• y) ï¼ y

Theorem â€œOver then âŠ•â€:                      (z ï¼ y) âŠ• y = z

Theorem â€œFractionsâ€: a ï¼¼ b  =  b ï¼ a

Declaration: _%-of_ : â„¤ â†’ â„¤ â†’ â„¤
Declaration: _div_ : â„¤ â†’ â„¤ â†’ â„¤

Axiom â€œDefinition of percentageâ€: x %-of y  =  (x div 100) Â· y
Axiom â€œInto the numeratorâ€: (x div z) Â· y = (x Â· y) div z

Theorem â€œPercentages commuteâ€: a %-of b  =  b %-of a
#+end_src
** â€œSwap or Pawsâ€ ---Take II
   :PROPERTIES:
   :CUSTOM_ID: Swap-or-Paws-Take-II
   :END:
#+begin_src haskell
Lemma â€œIrreflexivity of â‰¢â€: (p â‰¢ p) = false

Lemma â€œxor swapâ€:
     x = X âˆ§ y = Y
     â‡’â…  x := x â‰¢ y  â®
         y := x â‰¢ y  â®
         x := x â‰¢ y
     â†
     x = Y âˆ§ y = X
#+end_src
Wap: Xor Swap without the xor!!
#+begin_src haskell
Lemma â€œwapâ€:
     x = X âˆ§ y = Y
     â‡’â…  x := x â‰¡ y  â®
         y := x â‰¡ y  â®
         x := x â‰¡ y
     â†
     x = Y âˆ§ y = X
#+end_src

* Inductively Defined Types
  :PROPERTIES:
  :CUSTOM_ID: Inductively-Defined-Types
  :END:
** Inductive Theory of the Natural Numbers                     :Exercise:4_2:
   :PROPERTIES:
   :CUSTOM_ID: Inductive-Theory-of-the-Natural-Numbers
   :END:

 Here we develop an theory of the natural numbers based on induction over ~0~ and the successor operator ~suc_~.
    #+begin_src haskell
Theorem â€œSuccessorâ€: suc n = n + 1

Theorem â€œAssociativity of +â€: (a + b) + c = a + (b + c)

Declaration: _Â·_ : â„• â†’ â„• â†’ â„•

Axiom â€œDefinition of Â· for 0â€: 0 Â· n = 0
Axiom â€œDefinition of Â· for `suc`â€: (suc m) Â· n = n + m Â· n

Theorem â€œLeft-identity of Â·â€: 1 Â· n = n

Theorem â€œRight-zero of Â·â€: m Â· 0 = 0

Theorem â€œMultiplying the successorâ€: m Â· (suc n) = m + m Â· n

Theorem â€œSymmetry of Â·â€: m Â· n = n Â· m

Theorem â€œDistributivity of Â· over +â€: (k + m) Â· n = k Â· n + m Â· n

Theorem â€œAssociativity of Â·â€: (k Â· m) Â· n = k Â· (m Â· n)
 #+end_src

** Predecessors in the Inductive Theory of the Natural Numbers :Homework:8_5:
   :PROPERTIES:
   :CUSTOM_ID: Predecessors-in-the-Inductive-Theory-of-the-Natural-Numbers
   :END:
 #+begin_src haskell
Corollary â€œIdentity of +â€: 0 + a = a

Corollary â€œIdentity of Â·â€: 1 Â· a = a

Corollary â€œZero of Â·â€: 0 Â· a = 0

Theorem â€œSuccessor is non-decreasingâ€: a â‰¤ suc a

Theorem â€œSuccessor is increasingâ€: a < suc a
 #+end_src

   We define the predecessor function ~pred~ on natural numbers,
   and since it has to be defined for all natural numbers,
   we let it map 0 to 0:
 #+begin_src haskell
Declaration: pred : â„• â†’ â„•
Axiom â€œPredecessor of zeroâ€:       pred 0       = 0
Axiom â€œPredecessor of successorâ€:  pred (suc n) = n
 #+end_src

 Corresponding to the â€œSuccessorâ€ theorem ~suc n = n + 1~, we also have a â€œPredecessorâ€ theorem:
 #+begin_src haskell
Theorem â€œPredecessorâ€:  pred n = n - 1

Theorem â€œPredecessor is non-increasingâ€: pred a â‰¤ a

Theorem â€œPredecessor of non-zeroâ€:
    n â‰  0  â‰¡  suc (pred n) = n

Theorem â€œMonotonicity of predecessorâ€: a â‰¤ b â‡’ pred a â‰¤ pred b

Theorem â€œNon-<-monotonicity of predecessorâ€:
    Â¬ (a < b â‡’ pred a < pred b)[a, b â‰” ? , ? ]

Theorem â€œ<-Monotonicity of predecessorâ€:
    suc a < b â‡’ pred (suc a) < pred b
 #+end_src

** Inductive Theory of Sequences                   :Exercise_9_1:Homework_14:
   :PROPERTIES:
   :CUSTOM_ID: Inductive-Theory-of-Sequences
   :END:

 Here we develop a theory of sequences following LADM chapter 13.

 #+begin_src haskell
Sequences formalised via the new type constructor `Seq`
   #+end_src

   #+begin_src haskell
      Declaration: Seq : Type â†’ Type
   #+end_src


   Producing types ~Seq A~ of finite sequences with elements of type ~A~, and ~Seq A~
   is introduced as an inductive type with the following constructors:

       #+begin_src haskell
      Declaration: ğœ–  : Seq A
      Declaration: _â—ƒ_ : A â†’ Seq A â†’ Seq A
 #+end_src

  ~ğœ–~ (type ~\emptySeq~ or ~\eps~) stands for the empty sequence.

  For an element ~x : A~ and a sequence ~xs : Seq a~,
  the sequence ~x â—ƒ xs~ has ~x~ as its first element, also called head,
  and ~xs~ as its tail. For the symbol ~â—ƒ~, type ~\cons~.

  The binary operator ~â—ƒ~ **associates to the right**.

Corresponding to â€œZero is not successorâ€ on the natural numbers, here we have:
#+begin_src haskell
Axiom (13.3) â€œCons is not emptyâ€: x â—ƒ xs â‰  ğœ–
#+end_src

  The axiom corresponding to â€œCancellation of successorâ€ on the natural number then rounds off
  the characterisation of sequence equality as being equality of construction from `ğœ–` and `â—ƒ`:

#+begin_src haskell
Axiom (13.4) â€œCancellation of â—ƒâ€:
   x â—ƒ xs = y â—ƒ ys  â‰¡  x = y âˆ§ xs = ys
#+end_src

--------------------------------------------------------------------------------

   The induction principle for sequences implemented in ~By induction~ proofs is the following:
 #+begin_src haskell
       P[xs â‰” ğœ–]
    â‡’  (âˆ€ xs : Seq A â™ P â€¢ (âˆ€ x : A â€¢ P[xs â‰” x â—ƒ xs]))
    â‡’  (âˆ€ xs : Seq A â€¢ P)
   #+end_src
   An induction proof for either just `P`, or for `âˆ€ xs : Seq A â€¢ P`
   (it works the same for both goal statements),
   therefore takes the following shape:
   #+begin_src haskell
    By induction on `xs : Seq A`:
      Base case:

         âŸª Proof for `P[xs â‰” ğœ–]` âŸ«

      Induction step:

         âŸª Proof for `âˆ€ x : A â€¢ P[xs â‰” x â—ƒ xs]` âŸ«

           âŸª using: Induction hypothesis `P` âŸ«
   #+end_src
 Be careful to introduce a fresh variable instead of ~x~ for proving theorems
 that mention ~x~!

   #+begin_src haskell
Theorem (13.6) â€œCons decompositionâ€:
   âˆ€ xs : Seq A â€¢ xs = ğœ–  âˆ¨  (âˆƒ y â€¢ âˆƒ ys â€¢ xs = y â—ƒ ys)

Theorem (13.7) â€œTail is differentâ€:
    âˆ€ xs : Seq A â€¢ âˆ€ x : A â€¢ x â—ƒ xs â‰  xs

Theorem (13.7) â€œTail is differentâ€:
    x â—ƒ xs â‰  xs
 #+end_src

*** Membership
    :PROPERTIES:
    :CUSTOM_ID: Membership
    :END:
 #+begin_src haskell
Declaration: _âˆˆ_ : A â†’ Seq A â†’ ğ”¹

Axiom (13.10) â€œMembership in ğœ–â€:     x âˆˆ ğœ–         â‰¡  false
Axiom (13.11) â€œMembership in â—ƒâ€:    x âˆˆ (y â—ƒ ys)  â‰¡  x = y   âˆ¨  x âˆˆ ys

Theorem (13.16) â€œMembership in â–¹â€:
    x âˆˆ (ys â–¹ z)  â‰¡  x âˆˆ ys âˆ¨ x = z

Theorem (13.21) â€œMembership in âŒ¢â€:
    x âˆˆ ys âŒ¢ zs  â‰¡  x âˆˆ ys âˆ¨ x âˆˆ zs
 #+end_src
*** Mapping a Function over a Sequence
    :PROPERTIES:
    :CUSTOM_ID: Mapping-a-Function-over-a-Sequence
    :END:
 #+begin_src haskell
Declaration: map : (A â†’ B) â†’ Seq A â†’ Seq B
 #+end_src

 For example:
 ~map factorial [3, 0, 5] = [6, 1, 120]~.

 #+begin_src haskell
Axiom â€œDefinition of `map` for ğœ–â€:   map f ğœ– = ğœ–
Axiom â€œDefinition of `map` for â—ƒâ€:   map f (x â—ƒ xs) = f x â—ƒ map f xs

Theorem â€œDefinition of `map` for â–¹â€:
    map f (xs â–¹ x) = map f xs â–¹ f x

Theorem â€œDistributivity of `map` over âŒ¢â€:
    map f (xs âŒ¢ ys) = map f xs âŒ¢ map f ys
 #+end_src
*** Theorems to those of â„•
    :PROPERTIES:
    :CUSTOM_ID: Theorems-to-those-of-â„•
    :END:
 #+begin_src haskell
Axiom (13.3) â€œCons is not emptyâ€: x â—ƒ xs â‰  ğœ–

Theorem â€œCons is not emptyâ€: x â—ƒ xs = ğœ–  â‰¡  false

Axiom (13.4) â€œCancellation of â—ƒâ€:
   x â—ƒ xs = y â—ƒ ys  â‰¡  x = y âˆ§ xs = ys
 #+end_src
*** Snoc
    :PROPERTIES:
    :CUSTOM_ID: Snoc
    :END:
 #+begin_src haskell
Declaration: _â–¹_ : Seq A â†’ A â†’ Seq A

Axiom (13.12) â€œDefinition of â–¹ for ğœ–â€:         ğœ– â–¹ a = a â—ƒ ğœ–
Axiom (13.13) â€œDefinition of â–¹ for â—ƒâ€:   (a â—ƒ s) â–¹ b = a â—ƒ (s â–¹ b)

Fact (H12.1): (2 â—ƒ 5 â—ƒ 3 â—ƒ ğœ–) â–¹ 7  = 2 â—ƒ 5 â—ƒ 3 â—ƒ 7 â—ƒ ğœ–

Theorem (13.14) â€œSnoc is not emptyâ€:  xs â–¹ x â‰  ğœ–

Corollary â€œSnoc is not emptyâ€:  xs â–¹ x = ğœ–  â‰¡  false
 #+end_src
*** Catenation
    :PROPERTIES:
    :CUSTOM_ID: Catenation
    :END:
 #+begin_src haskell
Declaration: _âŒ¢_ : Seq A â†’ Seq A â†’ Seq A

Axiom (13.17)
      â€œLeft-identity of âŒ¢â€
      â€œDefinition of âŒ¢ for ğœ–â€:             ğœ– âŒ¢ ys = ys
Axiom (13.18)
      â€œMutual associativity of â—ƒ with âŒ¢â€
      â€œDefinition of âŒ¢ for â—ƒâ€:      (x â—ƒ xs) âŒ¢ ys = x â—ƒ (xs âŒ¢ ys)

Fact (H12.2):  (2 â—ƒ 7 â—ƒ 5 â—ƒ ğœ–) âŒ¢ (1 â—ƒ 9 â—ƒ ğœ–) = 2 â—ƒ 7 â—ƒ 5 â—ƒ 1 â—ƒ 9 â—ƒ ğœ–

Theorem (13.19) â€œRight-identity of âŒ¢â€:
    xs âŒ¢ ğœ– = xs

Theorem (13.20) â€œAssociativity of âŒ¢â€:
    (xs âŒ¢ ys) âŒ¢ zs = xs âŒ¢ (ys âŒ¢ zs)

Theorem (13.23) â€œEmpty concatenationâ€:
    xs âŒ¢ ys = ğœ–  â‰¡  xs = ğœ– âˆ§ ys = ğœ–
 #+end_src
*** Reverse
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-Reverse
    :END:
  #+begin_src haskell
Declaration: reverse : Seq A â†’ Seq A
Axiom â€œDefinition of `reverse` for ğœ–â€:  reverse ğœ– = ğœ–
Axiom â€œDefinition of `reverse` for â—ƒâ€:  reverse (x â—ƒ xs) = reverse xs â–¹ x

Theorem â€œcat-snocâ€:
    (us âŒ¢ vs) â–¹ w = us âŒ¢ (vs â–¹ w)

Theorem â€œReverse of âŒ¢â€:
   reverse (xs âŒ¢ ys) = reverse ys âŒ¢ reverse xs
  #+end_src
    We introduce the `head` and `tail` functions that extract the constituents of non-empty sequences:
  #+begin_src haskell
Declaration: head : Seq A â†’ A
Declaration: tail : Seq A â†’ Seq A
  #+end_src
    Note that the following axioms leave ~head ğœ–~ and ~tail ğœ–~ **undefined** ---
    nothing interesting can be proven about these expressions.
    (Only boring things like ~head ğœ– = head ğœ–~...)

  #+begin_src haskell
Axiom â€œDefinition of `head`â€: head (x â—ƒ xs) = x
Axiom â€œDefinition of `tail`â€: tail (x â—ƒ xs) = xs

Theorem â€œNon-empty-sequence extensionalityâ€:
    xs â‰  ğœ– â‡’ xs = head xs â—ƒ tail xs

Theorem â€œsnoc-catâ€:
    (us â–¹ v) âŒ¢ vs = us âŒ¢ (v â—ƒ vs)
  #+end_src

** Binary Trees :Exercise:12:
   :PROPERTIES:
   :CUSTOM_ID: Binary-Trees
   :END:

  As a simple graph, a relation may have the peculiar property of each node having
  at most two outgoing edges and no node is isolated (â€œforever aloneâ€); such
  graphs are known as *binary trees*.

  Since every node points to at most two other nodes, we can **represent** such
  relations inductively ---as we did with â„•atural numbers, sequences, and paths.

  We use symbols for the tree constructors that are intended
  to somewhat reflect the kind of downwards-growing tree drawing you see below:

  - ~â—¬~ --- type: ~\emptytree~ or ~\t0~
  - ~â—¿~ --- type: ~\lbranch~
  - ~â—º~ --- type: ~\rbranch~

  A nonempty tree ~(l â—¿ x â—º r)~ consists of a node carrying value ~x~
  and branching to the left subtree ~l~ and the right subtree ~r~:

#+begin_src haskell
Declaration: Tree : Type â†’ Type
Declaration:          â—¬   : Tree A
Declaration:        _â—¿_â—º_ : Tree A â†’ A â†’ Tree A â†’ Tree A

Declaration: example : Tree â„•
Axiom â€œDefinition of `example`â€:
  t1 = ((â—¬ â—¿ 2 â—º â—¬) â—¿ 3 â—º (â—¬ â—¿ 5 â—º â—¬))
       â—¿ 7 â—º
       (â—¬ â—¿ 10 â—º (â—¬ â—¿ 11 â—º â—¬))

Declaration: ï½¢_ï½£ : A â†’ Tree A  --- \lsingleton and \rsingleton
Axiom â€œSingleton treeâ€: ï½¢ x ï½£ = â—¬ â—¿ x â—º â—¬

Fact â€œAlternative definition of `example`â€:
  t1 = (ï½¢ 2 ï½£ â—¿ 3 â—º ï½¢ 5 ï½£)
       â—¿ 7 â—º
       (â—¬ â—¿ 10 â—º ï½¢ 11 ï½£)
#+end_src

  Read ~l â—¿ x â—º r~ as â€œ node ~x~ has two child trees, the left ~l~ and the right ~r~ â€.

(The notation is also suggestive of how such trees are actually **implemented**: A
  non-empty tree is a value ~x~ and a *pointer to the right child* and a *pointer to
  the left child*!)

  As with sequences, and other inductive data types, we can define operations on
  an inductive data type by considering the possible ways to form elements of
  this type.

E.g., We define the operator `_Ë˜` to stand for the mirroring function on trees
  --- via an inductive definition that covers all possible shapes of the
  argument tree:
#+begin_src haskell
Declaration: _Ë˜ : Tree A â†’ Tree A
Axiom â€œMirrorâ€: â—¬ Ë˜  = â—¬
Axiom â€œMirrorâ€: (l â—¿ x â—º r) Ë˜  =  (r Ë˜) â—¿ x â—º (l Ë˜)

Theorem â€œMirroring singleton treesâ€: ï½¢ x ï½£ Ë˜ = ï½¢ x ï½£  -- Singleton trees are fixpoints of mirroring:
#+end_src

  To show a property  ~P~ is true for all trees one needs to check that it is true for the simplest tree ~â—¬~
  and that if it is true for existing trees, then the way to make new trees *preserves* the truth of ~P~; i.e.,
  if ~P~ holds for ~l~ and ~r~ hold, then it needs to hold also for ~(l â—¿ x â—º r)~ should also be true:
#+begin_src haskell
Axiom â€œTree inductionâ€:
     P[t â‰” â—¬]
  âˆ§  ( âˆ€ l, r : Tree A; x : A
       â€¢ P[t â‰” l] âˆ§ P[t â‰” r]  â‡’  P[t â‰” l â—¿ x â—º r]
     )
  â‡’  (âˆ€ t : Tree A â€¢ P)

#+end_src

  Using this induction principle for our trees,
  we can prove that the above mirroring operation is an involution,
  just like reverse for sequences and converse for relations:

#+begin_src haskell
Theorem â€œSelf-inverse of tree mirrorâ€: âˆ€ t : Tree A â€¢ (t Ë˜) Ë˜ = t
Proof:
  Using â€œTree inductionâ€:
    Subproof for `â—¬ Ë˜ Ë˜ = â—¬`: By â€œMirrorâ€
    Subproof for `âˆ€ l, r : Tree A; x : A
         â€¢ (l Ë˜) Ë˜ = l âˆ§ (r Ë˜) Ë˜ = r
         â‡’ (l â—¿ x â—º r)Ë˜ Ë˜ = (l â—¿ x â—º r)`:
       For any `l, r, x`:
         Assuming â€œIHLâ€ `(l Ë˜) Ë˜ = l`,
                  â€œIHRâ€ `(r Ë˜) Ë˜ = r`:
             (l â—¿ x â—º r) Ë˜ Ë˜
           =âŸ¨ â€œMirrorâ€ âŸ©
             (l Ë˜ Ë˜) â—¿ x â—º (r Ë˜ Ë˜)
           =âŸ¨ Assumptions â€œIHLâ€ and â€œIHRâ€ âŸ©
             l â—¿ x â—º r

Declaration: size : Tree A â†’ â„•
Axiom â€œTree sizeâ€: size â—¬  = 0
Axiom â€œTree sizeâ€: size (l â—¿ x â—º r)  =  size l + 1 + size r

Lemma â€œSingleton tree sizeâ€: size ï½¢ x ï½£ = 1
Theorem â€œSize of mirrored treeâ€:
    âˆ€ t : Tree A â€¢ size (t Ë˜) = size t  --   Mirroring preserves size:
#+end_src

  Similar to the ~map~ function you have seen on sequences, we also define a ~map~
  function on tree, which creates a copy with â€œupdatedâ€ elements:

#+begin_src haskell
Declaration: map : (A â†’ B) â†’ Tree A â†’ Tree B
Axiom â€œTree mapâ€: map f â—¬ = â—¬
Axiom â€œTree mapâ€: map f (l â—¿ x â—º r) = (map f l) â—¿ (f x) â—º (map f r)
Theorem â€œSize of mapped treeâ€:
    âˆ€ t â€¢  size (map f t) = size t -- map preserver tree size:
#+end_src
*** Tree Traversals --- Seqentialising the Nodes
    :PROPERTIES:
    :CUSTOM_ID: Tree-Traversals-Seqentialising-the-Nodes
    :END:

  We define the three standard ways to sequentialise the tree elements while for
  each node keeping all elements of the left subtree before the elements of the
  right subtree (remember the names!):

#+begin_src haskell
Declaration: preOrder, inOrder, postOrder : Tree A â†’ Seq A

Axiom â€œDefinition of `preOrder`â€:
     preOrder â—¬ = ğœ–
  âˆ§  preOrder (l â—¿ x â—º r) = x â—ƒ preOrder l âŒ¢ preOrder r

Lemma â€œSingleton `preOrder`â€: preOrder ï½¢ x ï½£ = x â—ƒ ğœ–

Fact: preOrder example = 7 â—ƒ 3 â—ƒ 2 â—ƒ 5 â—ƒ 10 â—ƒ 11 â—ƒ ğœ–

Axiom â€œDefinition of `inOrder`â€:
     inOrder â—¬ = ğœ–
  âˆ§  inOrder (l â—¿ x â—º r) = inOrder l âŒ¢ x â—ƒ inOrder r

Lemma â€œSingleton `inOrder`â€: inOrder ï½¢ x ï½£ = x â—ƒ ğœ–

Fact: inOrder example = 2 â—ƒ 3 â—ƒ 5 â—ƒ 7 â—ƒ 10 â—ƒ 11 â—ƒ ğœ–

Axiom â€œDefinition of `postOrder`â€:
     postOrder â—¬ = ğœ–
  âˆ§  postOrder (l â—¿ x â—º r) = postOrder l âŒ¢ postOrder r â–¹ x

Lemma â€œSingleton `postOrder`â€: postOrder ï½¢ x ï½£ = x â—ƒ ğœ–

Fact: postOrder example = 2 â—ƒ 5 â—ƒ 3 â—ƒ 11 â—ƒ 10 â—ƒ 7 â—ƒ ğœ–

Theorem â€œmap commutes with inOrderâ€:
   âˆ€ f : A â†’ B â€¢ âˆ€ t : Tree a
   â€¢ map f (inOrder t) = inOrder (map f t)
#+end_src

  Note that in the theorem statement of ~â€œmap commutes with inOrderâ€~, the first
  ~map~ is the one from the theory of sequences, while the second ~map~ is the one
  from the current notebook.

* Order Theory :Assignment_2:
  :PROPERTIES:
  :CUSTOM_ID: Order-Theory
  :END:

** Introduction and Uniqueness of Bottoms
   :PROPERTIES:
   :CUSTOM_ID: Introduction-and-Uniqueness-of-Bottoms
   :END:

  Usually we have a collection ~Ï„~ of things that we are working with
  and are they ordered by relationship ~_âŠ‘_~.

  For example:

  1. People standing in a line are ordered by their position in the line.

   - For any two people, one will always be in-front of the other.
   - Such orders are called â€˜linearâ€™ --- since they are like a line.
   - For instance, the natural numbers order by size, ~â‰¤~, are linearly ordered.

  2. People in a city may be ordered by the floor level they live on.

   - People in different buildings, homes, are â€˜incomparableâ€™:
     Neither is â€˜aboveâ€™ the other.
   - Such orders are not linear.
   - For instance, members of a (business) hierarchy are only above
     their juniors and are not above their colleagues, and so are not
     linearly ordered. Likewise for â€˜treesâ€™ and â€˜graphsâ€™.

  3. The Booleans are ordered by implication, ~â‡’~.

     This relationship is completely determined by the requirement
     that â€œ ~false â‡’ true~ â€; i.e., ~false~ is smaller-than ~true~.

     Indeed, the collection of things that satisfy ~false~ is smaller than the
     collection of things that satisfy ~true~,
     since the empty collection is smaller than the collection comprising everything.

  Relationship:

     | Order        | Tree (hierarchy)      |
     | Linear order | List (flattened tree) |

  We can *formalise* this situation as follows.
  (Where ~âŠ‘~ is entered with ~\sqleq~ or ~\[=~.)


#+begin_src haskell
Conjunctional: _âŠ‘_

Declaration: Ï„ : Type
Declaration: _âŠ‘_ : Ï„ â†’ Ï„ â†’ ğ”¹

Axiom â€œReflexivity of âŠ‘â€: a âŠ‘ a
Axiom â€œTransitivity of âŠ‘â€: a âŠ‘ b  âˆ§  b âŠ‘ c  â‡’  a âŠ‘ c
Axiom â€œAntisymmetry of âŠ‘â€: a âŠ‘ b  âˆ§  b âŠ‘ a  â‡’  a = b

Theorem â€œIndirect reflexivity of âŠ‘â€:  a = b  â‡’  a âŠ‘ b

Theorem â€œMutual âŠ‘â€: a âŠ‘ b  âˆ§  b âŠ‘ a  â‰¡  a = b

Theorem â€œConjunctional Practice Î±â€: a âŠ‘ a âŠ‘ b  â‰¡  a âŠ‘ b

Theorem â€œConjunctional Practice Î²â€
   â€œSandwhich theoremâ€:
   a âŠ‘ b âŠ‘ a  â‰¡  a = b

Theorem â€œConjunctional Practice Î³â€
        â€œChainingâ€:
   a âŠ‘ b âŠ‘ c  â‡’  a âŠ‘ c

Declaration: âŠ¥â‚, âŠ¥â‚‚ : Ï„

Axiom â€œFirst bottomâ€:  âŠ¥â‚ âŠ‘ a
Axiom â€œSecond bottomâ€: âŠ¥â‚‚ âŠ‘ a

Theorem â€œBottoms are uniqueâ€: âŠ¥â‚ = âŠ¥â‚‚

Declaration: âŠ¥ : Ï„
Axiom â€œBottom of âŠ‘â€: âŠ¥ âŠ‘ a
#+end_src
** Uniqueness of Tops
   :PROPERTIES:
   :CUSTOM_ID: Uniqueness-of-Tops
   :END:
#+begin_src haskell
Declaration: âŠ¤â‚, âŠ¤â‚‚ : Ï„
Axiom â€œFirst topâ€: a âŠ‘ âŠ¤â‚
Axiom â€œSecond topâ€: b âŠ‘ âŠ¤â‚‚

Theorem â€œTops are uniqueâ€: âŠ¤â‚ = âŠ¤â‚‚

Declaration: âŠ¤ : Ï„
Axiom â€œTop is greatest elementâ€: a âŠ‘ âŠ¤

Theorem â€œTop is maximalâ€: âŠ¤ âŠ‘ a â‰¡ a = âŠ¤
#+end_src
** Divisibility
   :PROPERTIES:
   :CUSTOM_ID: Divisibility
   :END:

  We can order the naturals by their size, as is usual, but we can also order them by how they factor into each other.

  Say ~a | b~ precisely when ~b~ is a multiple of ~a~; i.e., ~b = q Â· a~ for some integer ~q~.

  Be careful:

       | $\frac{n}{m}$,   n / m | real division         | a number      |
       | n Ã· m                  | integer division      | a number      |
       | m âˆ£ n                  | divisibility relation | a proposition |

#+begin_src haskell
Declaration: _|_ : â„• â†’ â„• â†’ ğ”¹
Explanation: d | m â‰” â€œ`d` divides `m`â€
Explanation: d | m â‰” â€œ`d` is a divisor of `m`â€
Explanation: d | m â‰” â€œ`m` is a multiple of `d`â€

Axiom â€œReflexitivity of |â€: m | m
Axiom â€œAntisymmetry of |â€: m | n  âˆ§  n | m  â‡’  n = m
Axiom â€œTransitivity of |â€: m | n  âˆ§  n | k  â‡’  m | k

Theorem â€œMutual divisibilityâ€ â€œMutual |â€:  m | n  âˆ§  n | m  â‰¡  n = m

Axiom â€œDivisibility of multiplesâ€: m | (q Â· m)

Theorem â€œTop of |â€ â€œGreatest value of |â€: m | 0

Theorem â€œBottom of |â€ â€œLeast element of |â€: 1 | m

Theorem â€œTop of |â€ â€œGreatest value of |â€ â€œTop is maximalâ€:
   0 | n  â‰¡  n = 0

Theorem â€œBottom of |â€ â€œLeast element of |â€ â€œBottom is minimalâ€:
  m | 1  â‰¡  m = 1

Axiom â€œInvariance of Divisibility under semi-linear combinationsâ€:
   k | x  âˆ§  k | y  â‰¡  k | (x + a Â· y) âˆ§ k | y

Theorem â€œInvariance of Divisibility under semi-linear combinationsâ€:
  k | y â‡’ (k | (x + a Â· y) â‰¡ k | x)

Theorem â€œ|-Weakeningâ€ â€œ|-Strengtheningâ€:
  m | n  â‡’  m | (q Â· n)

Theorem â€œDivisibility of sumsâ€: a | b  âˆ§  a | c  â‡’  a | (b + c)

Theorem â€œDivisiblity of linear combinationsâ€:
  a | b  âˆ§  a | c  â‡’  a | (b Â· x + c Â· y)

Theorem â€œSufficient Case Analysis for |â€: a | b  âˆ¨  a | c  â‡’  a | (b Â· c)
#+end_src
** Meets and joins: Generalising Minima and Maxima
   :PROPERTIES:
   :CUSTOM_ID: Meets-and-joins-Generalising-Minima-and-Maxima
   :END:

  We have seen that ~_âŠ‘_ : Ï„ â†’ Ï„ â†’ ğ”¹~ generalises all of

   - ~_â‰¤_ : â„• â†’ â„• â†’ ğ”¹~
   - ~_âˆ£_ : â„• â†’ â„• â†’ ğ”¹~
   - ~_â‡’_ : ğ”¹ â†’ ğ”¹ â†’ ğ”¹~.

  Let us turn to seeing what generalises

   - ~_â†“_ : â„• â†’ â„• â†’ â„•~
   - ~_âˆ§_ : ğ”¹ â†’ ğ”¹ â†’ ğ”¹~
   - gcd (greatest common divisor) operation

  The generalision will be an operation ~_âŠ“_ : Ï„ â†’ Ï„ â†’ Ï„~ that will be the *greatest
  lower bound* of its arguments ---it is where two elements â€œmeetâ€.

  Enter ~âŠ“~ using ~\meet~.

#+begin_src haskell
Precedence 100 for: _âŠ“_
Declaration: _âŠ“_ : Ï„ â†’ Ï„ â†’ Ï„

Axiom â€œCharacterisation of âŠ“â€:
   c âŠ‘ a  âˆ§  c âŠ‘ b  â‰¡  c  âŠ‘  a âŠ“ b

Theorem â€œWeakening for âŠ“â€: a âŠ“ b  âŠ‘  a

Theorem â€œWeakening for âŠ“â€: a âŠ“ b  âŠ‘  b

Theorem â€œLeft-Monotonicity of âŠ“â€: a âŠ‘ b  â‡’  a âŠ“ c âŠ‘ b âŠ“ c

Theorem â€œIdempotency of âŠ“â€: a âŠ“ a  =  a

Theorem â€œInduced definition of inclusionâ€: a âŠ‘ b  â‰¡  a âŠ“ b = a
#+end_src

#+begin_src haskell
Precedence 100 for: _âŠ”_
Declaration: _âŠ”_ : Ï„ â†’ Ï„ â†’ Ï„

Axiom â€œCharacterisation of âŠ”â€:
  a âŠ‘ c  âˆ§  b âŠ‘ c  â‰¡  a âŠ” b  âŠ‘  c

Theorem â€œWeakening for âŠ”â€: a  âŠ‘  a âŠ” b

Theorem (3.76l) â€œWeakening for âŠ”â€: b  âŠ‘  a âŠ” b

Theorem â€œIdempotency of âŠ”â€:  a âŠ” a = a

Theorem â€œInduced definition of inclusionâ€: a âŠ‘ b  â‰¡ a âŠ” b = b
#+end_src

#+begin_src haskell
Theorem â€œAbsorptionâ€ â€œSqueeze Lawâ€ â€œSandwich Theoremâ€: a âŠ“ (b âŠ” a) = a

Theorem â€œAbsorptionâ€ â€œSqueeze Lawâ€ â€œSandwich Theoremâ€: a âŠ” (b âŠ“ a) = a

Theorem â€œWeakening from âŠ“ to âŠ”â€ â€œStrengthening from âŠ” to âŠ“â€:
    a âŠ“ b  âŠ‘  a âŠ” b

Theorem â€œSymmetry of âŠ“â€: a âŠ“ b = b âŠ“ a

Theorem â€œSymmetry of âŠ”â€: a âŠ” b = b âŠ” a

Theorem â€œGolden rule for âŠ“ and âŠ”â€: b âŠ“ a = a  â‰¡   b = a âŠ” b

Theorem â€œGolden rule for âŠ“ and âŠ”â€: b âŠ“ a = a âŠ” b  â‰¡   a = b

Theorem â€œIndirect zero of âŠ”â€:
  a âŠ” âŠ¤ âŠ‘ c  â‰¡  âŠ¤ âŠ‘ c
#+end_src

** Order on Integers                                           :Exercise:7_3:
   :PROPERTIES:
   :CUSTOM_ID: Exercise-7-3-IntegerOrder
   :END:
 #+begin_src haskell
Theorem â€œCancellation of unary minusâ€: - a = - b  â‰¡  a = b

Declaration: _<_ , _â‰¤_ , _>_ , _â‰¥_ : â„¤ â†’ â„¤ â†’ ğ”¹

Axiom (15.36) â€œLessâ€, â€œDefinition of <â€: a < b â‰¡ pos (b - a)
Axiom (15.37) â€œGreaterâ€, â€œDefinition of >â€: a > b â‰¡ pos (a - b)
Axiom (15.38) â€œAt mostâ€ â€œDefinition of â‰¤â€: a â‰¤ b â‰¡ a < b âˆ¨ a = b
Axiom (15.39) â€œAt leastâ€ â€œDefinition of â‰¥â€: a â‰¥ b â‰¡ a > b âˆ¨ a = b

Theorem â€œIrreflexivity of <â€: Â¬ (a < a)

Theorem â€œIrreflexivity of <â€: a = b â‡’ Â¬ (a < b)

Theorem â€œIrreflexivity of <â€: a < b â‡’ Â¬ (a = b)

Theorem â€œIrreflexivity of <â€: Â¬ (a < b âˆ§ a = b)

Theorem â€œConverse of <â€: a > b â‰¡ b < a

Theorem â€œConverse of â‰¤â€: a â‰¥ b â‰¡ b â‰¤ a

Theorem â€œIrreflexivity of >â€: Â¬ (a > a)

Theorem (15.40) â€œPositive elementsâ€: pos b â‰¡ 0 < b

Theorem (15.41) (15.41a) â€œTransitivityâ€ â€œTransitivity of <â€:
   a < b  âˆ§  b < c  â‡’  a < c

Theorem (15.41) (15.41b) â€œTransitivityâ€ â€œTransitivity of â‰¤ with <â€:
   a â‰¤ b  âˆ§  b < c  â‡’  a < c

Theorem (15.41) (15.41c) â€œTransitivityâ€ â€œTransitivity of < with â‰¤â€:
   a < b  âˆ§  b â‰¤ c  â‡’  a < c

Theorem (15.41) (15.41d) â€œTransitivityâ€ â€œTransitivity of â‰¤â€:
   a â‰¤ b  âˆ§  b â‰¤ c  â‡’  a â‰¤ c

Theorem â€œTransitivity of â‰¤â€:
   a â‰¤ b  â‡’  b â‰¤ c  â‡’  a â‰¤ c

Theorem â€œTransitivity of >â€:
   a > b  âˆ§  b > c  â‡’  a > c

Theorem (15.42) â€œ<-Isotonicity of +â€:
   a < b  â‰¡  a + d < b + d

Theorem â€œ<-Monotonicity of +â€:
   a < b  â‡’  a + d < b + d

Theorem â€œ<-Monotonicity of +â€:
   a < b â‡’ c < d â‡’ a + c < b + d

Theorem â€œâ‰¤-Isotonicity of +â€:
   a â‰¤ b  â‰¡  a + d â‰¤ b + d

Theorem â€œâ‰¤-Monotonicity of +â€:
   a â‰¤ b  â‡’  a + d â‰¤ b + d

Theorem â€œAsymmetry of <â€: Â¬ (a < b  âˆ§  b < a)

Theorem (15.44A) â€œTrichotomy â€” Aâ€:
    a < b  â‰¡  a = b  â‰¡  a > b

Theorem (15.44B) â€œTrichotomy â€” Bâ€:
    Â¬ (a < b  âˆ§  a = b  âˆ§  a > b)

Theorem (15.44) â€œTrichotomyâ€:
    (a < b  â‰¡  a = b  â‰¡  a > b) âˆ§
    Â¬ (a < b  âˆ§  a = b  âˆ§  a > b)
 #+end_src

** Positivity of Integers                                  :Exercise:7_1:7_2:
   :PROPERTIES:
   :CUSTOM_ID: Positivity-of-Integers
   :END:

   Following the â€œOrdered Domainsâ€ section of LADM Chapter 15 â€œA Theory of Integersâ€,
   we introduce the positivity predicate ~pos~ axiomatically.
 #+begin_src haskell
Theorem (15.7) â€œCancellation of Â·â€: c â‰  0 â‡’ (c Â· a = c Â· b  â‰¡  a = b)
Theorem (15.8) â€œCancellation of +â€:          a + b = a + c  â‰¡  b = c
Theorem â€œNon-zero multiplicationâ€: a â‰  0 â‡’ b â‰  0 â‡’ a Â· b â‰  0

Declaration: pos : â„¤ â†’ ğ”¹

Axiom (15.30) â€œPositivity under +â€: pos a âˆ§ pos b â‡’ pos (a + b)
Axiom (15.31) â€œPositivity under Â·â€: pos a âˆ§ pos b â‡’ pos (a Â· b)
Axiom (15.32) â€œNon-positivity of 0â€: Â¬ pos 0
Axiom (15.33) â€œPositivity under unary minusâ€: b â‰  0 â‡’ (pos b â‰¡ Â¬ pos (- b))

Theorem (15.33b) â€œPositivity under unary minusâ€: b â‰  0 â‡’ (pos (- b) â‰¡ Â¬ pos b)

Theorem (15.33c) â€œPositivity under unary minusâ€: (pos (- b) â‰¡ pos b) â‡’ b = 0

Theorem â€œPositive implies non-zeroâ€: pos a â‡’ a â‰  0

Theorem (15.34) â€œPositivity of squaresâ€: b â‰  0 â‡’ pos (b Â· b)

Corollary â€œPositivity of 1â€: pos 1

Theorem â€œPositivityâ€: pos a â‰¡ a â‰  0 âˆ§ Â¬ pos (- a)

Theorem (15.35) â€œPositivity under positive Â·â€: pos a â‡’ (pos b â‰¡ pos (a Â· b))
 #+end_src

** Mixed Monotonicity                                      :Exercise:8_2:8_3:
   :PROPERTIES:
   :CUSTOM_ID: Mixed-Monotonicity
   :END:

 #+begin_src haskell
Theorem â€œMultiplying by 2â€: 2 Â· x = x + x

Theorem â€œMultiplying by 3â€: 3 Â· x = x + x + x

Theorem â€œLeft-antitonicity of â‡’â€: (p â‡’ q) â‡’ ((q â‡’ r) â‡’ (p â‡’ r))

Theorem â€œRight-monotonicity of â‡’â€: (p â‡’ q) â‡’ ((r â‡’ p) â‡’ (r â‡’ q))

Theorem  â€œLeft-antitonicity of <â€: (p â‰¤ q) â‡’ ((q < r) â‡’ (p < r))

Theorem â€œRight-monotonicity of <â€: (p â‰¤ q) â‡’ ((r < p) â‡’ (r < q))

Theorem  â€œLeft-antitonicity of â‰¤â€: (p â‰¤ q) â‡’ ((q â‰¤ r) â‡’ (p â‰¤ r))

Theorem â€œRight-monotonicity of â‰¤â€: (p â‰¤ q) â‡’ ((r â‰¤ p) â‡’ (r â‰¤ q))

Theorem  â€œWeak left-antitonicity of <â€: (p < q) â‡’ ((q < r) â‡’ (p < r))

Theorem â€œWeak right-monotonicity of <â€: (p < q) â‡’ ((r < p) â‡’ (r < q))
 #+end_src

** â€œIndirect Equalityâ€ on Integers                             :Exercise:8_1:
   :PROPERTIES:
   :CUSTOM_ID: Indirect-Equality-on-Integers
   :END:

 Following the â€œOrdered Domainsâ€ secion of LADM Chapter 15 â€œA Theory of
 Integersâ€, we provide the usual ordering relations on the integers and some of
 their properties.

 #+begin_src haskell
Theorem (15.47) â€œIndirect Equalityâ€ â€œIndirect Equality from belowâ€:
  a = b  â‰¡  (âˆ€ z â€¢ z â‰¤ a  â‰¡  z â‰¤ b)

Theorem â€œIndirect Equalityâ€ â€œIndirect Equality from aboveâ€:
  a = b  â‰¡  (âˆ€ z â€¢ a â‰¤ z  â‰¡  b â‰¤ z)

Declaration: _â†“_ : â„¤ â†’ â„¤ â†’ â„¤
Declaration: _â†‘_ : â„¤ â†’ â„¤ â†’ â„¤

Axiom (15.53) (15.53a) â€œDefinition of â†“â€:
   z â‰¤ x â†“ y  â‰¡  z â‰¤ x âˆ§ z â‰¤ y

Axiom (15.53) (15.53b) â€œDefinition of â†‘â€:
   x â†‘ y â‰¤ z â‰¡  x â‰¤ z âˆ§ y â‰¤ z

Theorem (15.54) â€œSymmetry of â†“â€:  x â†“ y = y â†“ x

Theorem (15.54) â€œSymmetry of â†‘â€:  x â†‘ y = y â†‘ x

Theorem (15.55) â€œAssociativity of â†“â€: (x â†“ y) â†“ z = x â†“ (y â†“ z)

Theorem (15.55) â€œAssociativity of â†‘â€: (x â†‘ y) â†‘ z = x â†‘ (y â†‘ z)

Theorem (15.56) â€œIdempotency of â†“â€: x â†“ x = x

Theorem (15.56) â€œIdempotency of â†‘â€:  x â†‘ x = x

Theorem (15.57) â€œMinimum is lower boundâ€: x â†“ y â‰¤ x  âˆ§  x â†“ y â‰¤ y

Theorem (15.57) â€œMaximum is upper boundâ€: x â‰¤ x â†‘ y  âˆ§  y â‰¤ x â†‘ y

Theorem (15.58) â€œAt most via minimumâ€: x â‰¤ y  â‰¡  x â†“ y = x

Theorem (15.58) â€œAt most via maximumâ€: x â‰¤ y  â‰¡  x â†‘ y = y
 #+end_src

* Quantification
  :PROPERTIES:
  :CUSTOM_ID: Quantification
  :END:
** Universal âˆ€
   :PROPERTIES:
   :CUSTOM_ID: Universal
   :END:
 #+begin_src haskell
Axiom â€œLeibniz for âˆ€ rangeâ€:
    (âˆ€ x â€¢ Râ‚ â‰¡ Râ‚‚) â‡’ ((âˆ€ x â™ Râ‚ â€¢ P) â‰¡ (âˆ€ x â™ Râ‚‚ â€¢ P))

Axiom â€œLeibniz for âˆ€ bodyâ€:
    (âˆ€ x â€¢ R â‡’ (Pâ‚ â‰¡ Pâ‚‚)) â‡’ ((âˆ€ x â™ R â€¢ Pâ‚) â‰¡ (âˆ€ x â™ R â€¢ Pâ‚‚))

Axiom (8.11) â€œSubstitutionâ€ â€œSubstitution into âˆ€â€:
   (âˆ€ x â™ R â€¢ P)[y â‰” F] â‰¡ âˆ€ x â™ R[y â‰” F] â€¢ P[y â‰” F]

Axiom (8.13) â€œEmpty range for âˆ€â€:
  (âˆ€ x â™ false â€¢ P)  â‰¡  true

Axiom (8.14) â€œOne-point rule for âˆ€â€:
  (âˆ€ x â™ x = E â€¢ P)  â‰¡  P[x â‰” E]

Axiom (8.15) â€œDistributivity of âˆ€ over âˆ§â€:
  (âˆ€ x â™ R â€¢ P) âˆ§ (âˆ€ x â™ R â€¢ Q) â‰¡ (âˆ€ x â™ R â€¢ P âˆ§ Q)

Axiom (8.17) â€œRange split for âˆ€â€:
     (âˆ€ x â™ R âˆ¨ S  â€¢ P)  âˆ§  (âˆ€ x â™ R âˆ§ S  â€¢ P)
   â‰¡ (âˆ€ x â™ R      â€¢ P)  âˆ§  (âˆ€ x â™ S      â€¢ P)

Axiom (8.20) â€œNesting for âˆ€â€:
    (âˆ€ x, y â™ R âˆ§ S â€¢ P)
  â‰¡ (âˆ€ x â™ R â€¢ (âˆ€ y â™ S â€¢ P))

Theorem â€œReplacement in âˆ€â€:
    (âˆ€ y â™ R âˆ§ e = f â€¢ P[x â‰” e])
  â‰¡ (âˆ€ y â™ R âˆ§ e = f â€¢ P[x â‰” f])

Axiom (8.20a) â€œDummy list permutation for âˆ€â€:
   (âˆ€ x, y â™ R â€¢ P) â‰¡ (âˆ€ y, x â™ R â€¢ P)

Theorem (8.19) â€œInterchange of dummies for âˆ€â€:
    (âˆ€ x â™ R â€¢ (âˆ€ y â™ S â€¢ P))
  â‰¡ (âˆ€ y â™ S â€¢ (âˆ€ x â™ R â€¢ P))

Axiom (9.2) â€œTrading for âˆ€â€:
   (âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ x â€¢ R â‡’ P)

Theorem (9.3) (9.3a) â€œTrading for âˆ€â€:
   (âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ x â€¢ Â¬ R âˆ¨ P)

Theorem (9.3) (9.3b) â€œTrading for âˆ€â€:
   (âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ x â€¢ R âˆ§ P â‰¡ R)

Theorem (9.3) (9.3b) â€œTrading for âˆ€â€:
   (âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ x â€¢ R âˆ§ P â‰¡ R)

Theorem (9.3) (9.3c) â€œTrading for âˆ€â€:
   (âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ x â€¢ R âˆ¨ P â‰¡ P)

Theorem (9.4) (9.4a) â€œTrading for âˆ€â€:
   (âˆ€ x â™ Q âˆ§ R â€¢ P) â‰¡ (âˆ€ x â™ Q â€¢ R â‡’ P)

Theorem (9.4) (9.4b) â€œTrading for âˆ€â€:
   (âˆ€ x â™ Q âˆ§ R â€¢ P) â‰¡ (âˆ€ x â™ Q â€¢ Â¬ R âˆ¨ P)

Theorem (9.4) (9.4c) â€œTrading for âˆ€â€:
   (âˆ€ x â™ Q âˆ§ R â€¢ P) â‰¡ (âˆ€ x â™ Q â€¢ R âˆ§ P â‰¡ R)

Theorem (9.4) (9.4d) â€œTrading for âˆ€â€:
   (âˆ€ x â™ Q âˆ§ R â€¢ P) â‰¡ (âˆ€ x â™ Q â€¢ R âˆ¨ P â‰¡ P)

Theorem â€œLeibniz for âˆ€ bodyâ€:
    (âˆ€ x â™ R â€¢ Pâ‚ â‰¡ Pâ‚‚) â‡’ ((âˆ€ x â™ R â€¢ Pâ‚) â‰¡ (âˆ€ x â™ R â€¢ Pâ‚‚))

Theorem (8.18) â€œRange split for âˆ€â€:
     (âˆ€ x â™ R âˆ¨ S  â€¢ P)
   â‰¡ (âˆ€ x â™ R      â€¢ P)
   âˆ§ (âˆ€ x â™ S      â€¢ P)

Axiom (9.5) â€œDistributivity of âˆ¨ over âˆ€â€:
    P âˆ¨ (âˆ€ x â™ R â€¢ Q) â‰¡ (âˆ€ x â™ R â€¢ P âˆ¨ Q)

Theorem (9.6): P âˆ¨ (âˆ€ x â€¢ Â¬ R) â‰¡ (âˆ€ x â™ R â€¢ P)

Theorem â€œDistributivity of â‡’ over âˆ€â€: P â‡’ (âˆ€ x â™ R â€¢ Q) â‰¡ (âˆ€ x â™ R â€¢ P â‡’ Q)

Theorem (9.7) â€œDistributivity of âˆ§ over âˆ€â€:
    Â¬(âˆ€ x â€¢ Â¬ R)  â‡’  (P âˆ§ (âˆ€ x â™ R â€¢ Q)  â‰¡  (âˆ€ x â™ R â€¢ P âˆ§ Q))

Theorem (9.8) â€œTrue âˆ€ bodyâ€: (âˆ€ x â™ R â€¢ true)

Theorem â€œIntroducing fresh âˆ€â€: P â‡’ (âˆ€ x â™ R â€¢ P)

Theorem (9.9) â€œSub-distributivity of âˆ€ over â‰¡â€:
   (âˆ€ x â™ R â€¢ P â‰¡ Q)
   â‡’ ((âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ x â™ R â€¢ Q))

Theorem (9.10) â€œRange weakening for âˆ€â€ â€œRange strengthening for âˆ€â€:
    (âˆ€ x â™ Q âˆ¨ R â€¢ P) â‡’ (âˆ€ x â™ Q â€¢ P)

Theorem (9.11) â€œBody weakening for âˆ€â€ â€œBody strengthening for âˆ€â€:
    (âˆ€ x â™ R â€¢ P âˆ§ Q) â‡’ (âˆ€ x â™ R â€¢ P)

Theorem (9.12) â€œMonotonicity of âˆ€â€ â€œBody monotonicity of âˆ€â€:
    (âˆ€ x â™ R â€¢ Q â‡’ P) â‡’ ((âˆ€ x â™ R â€¢ Q) â‡’ (âˆ€ x â™ R â€¢ P))
#+end_src
** COMMENT more
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-more
   :END:
 #+begin_src haskell
Proof:
  Using â€œShuntingâ€:
    Subproof for `(âˆ€ x â™ R â€¢ Q â‡’ P) âˆ§ (âˆ€ x â™ R â€¢ Q) â‡’ (âˆ€ x â™ R â€¢ P)`:
        (âˆ€ x â™ R â€¢ Q â‡’ P) âˆ§ (âˆ€ x â™ R â€¢ Q)
      â‰¡âŸ¨ â€œDistributivity of âˆ€ over âˆ§â€ âŸ©
        (âˆ€ x â™ R â€¢ (Q â‡’ P) âˆ§ Q)
      â‰¡âŸ¨ (3.66) âŸ©
        (âˆ€ x â™ R â€¢ P âˆ§ Q)
      â‡’âŸ¨ â€œBody weakening for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ P)

Activate monotonicity property â€œBody monotonicity of âˆ€â€

Theorem (9.12a) â€œRange antitonicity of âˆ€â€:
    (âˆ€ x â€¢ Q â‡’ R) â‡’ ((âˆ€ x â™ R â€¢ P) â‡’ (âˆ€ x â™ Q â€¢ P))
Proof:
    (âˆ€ x â€¢ Q â‡’ R)
  â‡’âŸ¨ â€œBody monotonicity of âˆ€â€ with â€œAntitonicity of â‡’â€ âŸ©
    (âˆ€ x â€¢ (R â‡’ P) â‡’ (Q â‡’ P))
  â‡’âŸ¨ â€œBody monotonicity of âˆ€â€ âŸ©
    (âˆ€ x â€¢ R â‡’ P) â‡’ (âˆ€ x â€¢ Q â‡’ P)
  â‰¡âŸ¨ â€œTrading for âˆ€â€ (9.2) âŸ©
    (âˆ€ x â™ R â€¢ P) â‡’ (âˆ€ x â™ Q â€¢ P)

Theorem (9.12a) â€œRange antitonicity of âˆ€â€:
    (âˆ€ x â™ Â¬ P â€¢ Q â‡’ R) â‡’ ((âˆ€ x â™ R â€¢ P) â‡’ (âˆ€ x â™ Q â€¢ P))
Proof:
    (âˆ€ x â™ Â¬ P â€¢ Q â‡’ R)
  â‰¡âŸ¨ â€œTrading for âˆ€â€, â€œDouble negationâ€ âŸ©
    (âˆ€ x â€¢ R âˆ¨ Â¬ Q âˆ¨ P)
  â‰¡âŸ¨ â€œAbsorptionâ€ âŸ©
    (âˆ€ x â€¢ (R âˆ§ Â¬ P) âˆ¨ (Â¬ Q âˆ¨ P))
  â‰¡âŸ¨ â€œDe Morganâ€, â€œDouble negationâ€ âŸ©
    (âˆ€ x â€¢ Â¬ (Â¬ R âˆ¨ P) âˆ¨ (Â¬ Q âˆ¨ P))
  â‰¡âŸ¨ â€œDefinition of â‡’â€ (3.59) âŸ©
    (âˆ€ x â€¢ (R â‡’ P) â‡’ (Q â‡’ P))
  â‡’âŸ¨ â€œBody monotonicity of âˆ€â€ âŸ©
    (âˆ€ x â€¢ R â‡’ P) â‡’ (âˆ€ x â€¢ Q â‡’ P)
  â‰¡âŸ¨ â€œTrading for âˆ€â€ âŸ©
    (âˆ€ x â™ R â€¢ P) â‡’ (âˆ€ x â™ Q â€¢ P)

Activate antitonicity property â€œRange antitonicity of âˆ€â€

Theorem â€œLeibniz for âˆ€ bodyâ€:
    (âˆ€ x â€¢ Pâ‚ â‰¡ Pâ‚‚) â‡’ ((âˆ€ x â™ R â€¢ Pâ‚) â‰¡ (âˆ€ x â™ R â€¢ Pâ‚‚))
Proof:
    (âˆ€ x â€¢ Pâ‚ â‰¡ Pâ‚‚)
  â‰¡âŸ¨ â€œZero of âˆ¨â€ âŸ©
    (âˆ€ x â™ true âˆ¨ R â€¢ Pâ‚ â‰¡ Pâ‚‚)
  â‡’âŸ¨ â€œRange weakening for âˆ€â€ âŸ©
    (âˆ€ x â™ R â€¢ Pâ‚ â‰¡ Pâ‚‚)
  â‡’âŸ¨ â€œLeibniz for âˆ€ bodyâ€ âŸ©
    (âˆ€ x â™ R â€¢ Pâ‚) â‰¡ (âˆ€ x â™ R â€¢ Pâ‚‚)

### Instantiation


MarkDown:
  â€œInstantiationâ€ is one of the key properties of universal quantification:
  Having `(âˆ€ x â€¢ P)` implies having any `x`-instance of `P` you choose, with arbitrary expression `E` of the same type as `x`.

  Since CalcCheck does not perform second-order matching,
  the substitution needs to be made explicit in most applications of â€œInstantiationâ€.

Theorem (9.13) â€œInstantiationâ€: (âˆ€ x â€¢ P) â‡’ P[x â‰” E]
Proof:
    P[x â‰” E]
  â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
    (âˆ€ x â™ x = E â€¢ P)
  â‡âŸ¨ â€œRange weakening for âˆ€â€, â€œDefinition of â‡â€ âŸ©
    (âˆ€ x â™ true âˆ¨ x = E â€¢ P)
  â‰¡âŸ¨ â€œZero of âˆ¨â€ âŸ©
    (âˆ€ x â™ true â€¢ P)
  â‰¡âŸ¨ â€œReflexivity of â‰¡â€ âŸ©
    (âˆ€ x â€¢ P)

Theorem (9.13a) â€œInstantiationâ€: (âˆ€ x â€¢ P) â‡’ P[x â‰” x]
Proof:
    (âˆ€ x â€¢ P)
  â‡’âŸ¨ â€œInstantiationâ€ âŸ©
    P[x â‰” x]

Theorem (9.13b) â€œInstantiationâ€: (âˆ€ x â™ R â€¢ P) â‡’ (R â‡’ P)[x â‰” E]
Proof:
    (âˆ€ x â™ R â€¢ P)
  â‰¡âŸ¨ â€œTrading for âˆ€â€ âŸ©
    âˆ€ x â€¢ R â‡’ P
  â‡’âŸ¨ â€œInstantiationâ€ âŸ©
    (R â‡’ P)[x â‰” E]

MarkDown:
  Eliminating the substitution from the RHS of (9.13a) is legal, but results in a theorem statement for which CalcCheck derives `Â¬occurs(`x`,`P`)`:
  ````
  Theorem (9.13a') â€œInstantiationâ€: (âˆ€ x â€¢ P) â‡’ P
  Proof:
      (âˆ€ x â€¢ P)
    â‡’âŸ¨ â€œInstantiationâ€ (9.13) âŸ©
      P[x â‰” x]
    â‰¡âŸ¨ Substitution âŸ©
      P
  ````
  Since this is not very useful, and since the presence of (9.13a') could be confusing, we do not include this for the time being.

  It is, however, the opposite of â€œIntroducing fresh âˆ€â€ for `true` range, and we include the resulting sharper version,
  which from this reasoning would naturally be proven via mutual implication (explore how far you can get using (9.6) instead!):

MarkDown:
  Needs work on `tt_condequations'` or vicinity:
  ````
  Theorem â€œFresh âˆ€â€: P â‰¡ (âˆ€ x â€¢ P)
  Proof:
      P â‰¡ (âˆ€ x â€¢ P)
    â‡âŸ¨ â€œMutual implicationâ€ with â€œIntroducing fresh âˆ€â€ âŸ©
      (âˆ€ x â€¢ P) â‡’ P
    â‰¡âŸ¨ Substitution âŸ©
      (âˆ€ x â€¢ P) â‡’ P[x â‰” x]
    â€” This is â€œInstantiationâ€ (9.13)
  ````

MarkDown:
  The proof above was added when the following proof timed out on 2019-11-28 due to an programming mistake:
  ````
  Theorem â€œFresh âˆ€â€: P â‰¡ (âˆ€ x â€¢ P)
  Proof:
    Using â€œMutual implicationâ€:
      Subproof for `P â‡’ (âˆ€ x â€¢ P)`:
        By â€œIntroducing fresh âˆ€â€
      Subproof for `(âˆ€ x â€¢ P) â‡’ P`:
          (âˆ€ x â€¢ P)
        â‡’âŸ¨ â€œInstantiationâ€ (9.13) âŸ©
          P[x â‰” x]
        â‰¡âŸ¨ Substitution âŸ©
          P
  ````
  The proof above is actually nicer,
  so we leave that active now.

Theorem â€œFresh âˆ€â€: P â‰¡ (âˆ€ x â€¢ P)
Proof:
  Using â€œMutual implicationâ€:
    Subproof for `P â‡’ (âˆ€ x â€¢ P)`:
      By â€œIntroducing fresh âˆ€â€
    Subproof for `(âˆ€ x â€¢ P) â‡’ P`:
        (âˆ€ x â€¢ P)
      â‡’âŸ¨ â€œInstantiationâ€ (9.13) âŸ©
        P[x â‰” x]
      â‰¡âŸ¨ Substitution âŸ©
        P

## Disjoint Range Split


MarkDown:
  We now can prove the theorem version of (8.16) â€œDisjoint range splitâ€.

Theorem (8.16) â€œDisjoint range split for âˆ€â€:
   (âˆ€ x â€¢ R âˆ§ S â‰¡ false) â‡’
   ((âˆ€ x â™ R âˆ¨ S â€¢ P) â‰¡ (âˆ€ x â™ R â€¢ P) âˆ§ (âˆ€ x â™ S â€¢ P))
Proof:
  Assuming `(âˆ€ x â€¢ R âˆ§ S â‰¡ false)`:
      (âˆ€ x â™ R â€¢ P) âˆ§ (âˆ€ x â™ S â€¢ P)
    â‰¡âŸ¨ (8.17) â€œRange split for âˆ€â€ âŸ©
      (âˆ€ x â™ R âˆ¨ S â€¢ P) âˆ§ (âˆ€ x â™ R âˆ§ S â€¢ P)
    â‰¡âŸ¨ Subproof for `(âˆ€ x â™ R âˆ§ S â€¢ P) â‰¡ (âˆ€ x â™ false â€¢ P)`:
           (âˆ€ x â™ R âˆ§ S â€¢ P) â‰¡ (âˆ€ x â™ false â€¢ P)
         â‡âŸ¨ â€œLeibniz for âˆ€ rangeâ€ âŸ©
           (âˆ€ x â€¢ R âˆ§ S â‰¡ false)   â€” This is Assumption `(âˆ€ x â€¢ R âˆ§ S â‰¡ false)`
      âŸ©
      (âˆ€ x â™ R âˆ¨ S â€¢ P) âˆ§ (âˆ€ x â™ false â€¢ P)
    â‰¡âŸ¨ â€œEmpty range for âˆ€â€ âŸ©
      (âˆ€ x â™ R âˆ¨ S â€¢ P) âˆ§ true
    â‰¡âŸ¨ â€œIdentity of âˆ§â€ âŸ©
      (âˆ€ x â™ R âˆ¨ S â€¢ P)

MarkDown:
  The disjoint version of range split is actually not interesting here,
  since conjunction is idempotemt so that we have the stronger (8.18) of range split.

  Just to make (8.16) available here, too, it is easy to prove it from (8.18):

Theorem (8.16) â€œDisjoint range split for âˆ€â€:
   (âˆ€ x â€¢ R âˆ§ S â‰¡ false) â‡’
   ((âˆ€ x â™ R âˆ¨ S â€¢ P) â‰¡ (âˆ€ x â™ R â€¢ P) âˆ§ (âˆ€ x â™ S â€¢ P))
Proof:
  Assuming `(âˆ€ x â€¢ R âˆ§ S â‰¡ false)`: By (8.18) â€œRange split for âˆ€â€

## Change of Dummy


MarkDown:
  On p. 151 of LADM you find a proof for (8.22) â€œChange of dummyâ€ (with less formal theorem statement) â€” turn that into a CalcCheck proof!

Theorem (8.22) â€œChange of dummyâ€:
  âˆ€ f â€¢ âˆ€ g â€¢
    (âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x)
    â‡’ (  (âˆ€ x â™ R          â€¢ P         )
       â‰¡ (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y])
       )
Proof:
  For any `f`, `g`:
    Assuming â€œInverseâ€ `âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x`:
        (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y])
      â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
        (âˆ€ y â™ R[x â‰” f y] â€¢ (âˆ€ x â™ x = f y â€¢ P))
      â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
        (âˆ€ y, x â™ R[x â‰” f y] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ y, x â™ R[x â‰” z][z â‰” f y] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œReplacementâ€ (3.84a) âŸ©
        (âˆ€ y, x â™ R[x â‰” z][z â‰” x] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ y, x â™ R âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œDummy list permutation for âˆ€â€ âŸ©
        (âˆ€ x, y â™ R âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ (âˆ€ y â™ x = f y â€¢ P))
      â‰¡âŸ¨ Assumption â€œInverseâ€ âŸ©
        (âˆ€ x â™ R â€¢ (âˆ€ y â™ y = g x â€¢ P))
      â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ P[y â‰” g x])
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ x â™ R â€¢ P)

MarkDown:
  If you look for uses of (8.22) in LADM, you'll notice that it is actually never applied as such,
  but relying on additional preconditions essentially about definedness of `f` and `g`.

  The following variant comes closer to what is needed --- can you adapt your proof from above?

  (Questions of the calibre of the remaining proofs here will **not** be on any 2DM3 exam.)

Theorem â€œChange of dummy â€” variantâ€:
  (âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‡’  y = g x)
  â‡’ (  (âˆ€ x â™ R âˆ§ x = f (g x) â€¢ P)
     â‰¡ (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y]))
Proof:
  Assuming â€œInverseâ€ `âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‡’  y = g x`:
      (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y])
    â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
      (âˆ€ y â™ R[x â‰” f y] â€¢ (âˆ€ x â™ x = f y â€¢ P))
    â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
      (âˆ€ y, x â™ R[x â‰” f y] âˆ§ x = f y â€¢ P)
    â‰¡âŸ¨ Substitution âŸ©
      (âˆ€ y, x â™ R[x â‰” z][z â‰” f y] âˆ§ x = f y â€¢ P)
    â‰¡âŸ¨ â€œReplacementâ€ (3.84a) âŸ©
      (âˆ€ y, x â™ R[x â‰” z][z â‰” x] âˆ§ x = f y â€¢ P)
    â‰¡âŸ¨ Substitution âŸ©
      (âˆ€ y, x â™ R âˆ§ x = f y â€¢ P)
    â‰¡âŸ¨ â€œDummy list permutation for âˆ€â€ âŸ©
      (âˆ€ x, y â™ R âˆ§ x = f y â€¢ P)
    â‰¡âŸ¨ Subproof for `âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x âˆ§ x = f y`:
          âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x âˆ§ x = f y
        â‰¡âŸ¨ (3.60) âŸ©
          âˆ€ x â€¢ âˆ€ y â€¢ x = f y  â‡’  y = g x
             â€” This is assumption â€œInverseâ€
      âŸ©
      (âˆ€ x, y â™ R âˆ§ y = g x âˆ§ x = f y â€¢ P)
    â‰¡âŸ¨ Substitution âŸ©
      (âˆ€ x, y â™ R âˆ§ y = g x âˆ§ (x = f z)[z â‰” y] â€¢ P)
    â‰¡âŸ¨ â€œReplacementâ€ (3.84a), substitution âŸ©
      (âˆ€ x, y â™ R âˆ§ y = g x âˆ§ x = f (g x) â€¢ P)
    â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
      (âˆ€ x â™ R âˆ§ x = f (g x) â€¢ (âˆ€ y â™ y = g x â€¢ P))
    â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
      (âˆ€ x â™ R âˆ§ x = f (g x) â€¢ P[y â‰” g x])
    â‰¡âŸ¨ Substitution âŸ©
      (âˆ€ x â™ R âˆ§ x = f (g x) â€¢ P)

MarkDown:
  For the version of (8.22) with restricted inverse assumption below,
  the following lemma comes in handy:

Lemma â€œRange replacement in nested âˆ€â€:
    (âˆ€ x â™ R â€¢ (âˆ€ y â€¢ Qâ‚ â‰¡ Qâ‚‚))
    â‡’ (  (âˆ€ x â™ R â€¢ (âˆ€ y â™ Qâ‚ â€¢ P))
       â‰¡ (âˆ€ x â™ R â€¢ (âˆ€ y â™ Qâ‚‚ â€¢ P))
      )
Proof:
      âˆ€ x â™ R â€¢ (âˆ€ y â€¢ Qâ‚ â‰¡ Qâ‚‚)
    â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
      âˆ€ x â€¢ âˆ€ y â™ R â€¢ Qâ‚ â‰¡ Qâ‚‚
    â‰¡âŸ¨ â€œTrading for âˆ€â€ âŸ©
      âˆ€ x â€¢ âˆ€ y â€¢ R â‡’ (Qâ‚ â‰¡ Qâ‚‚)
    â‰¡âŸ¨ (3.62) âŸ©
      âˆ€ x â€¢ âˆ€ y â€¢ R âˆ§ Qâ‚ â‰¡ R âˆ§ Qâ‚‚
    â‡’âŸ¨ Subproof:
          Assuming â€œAâ€ `âˆ€ x â€¢ âˆ€ y â€¢ R âˆ§ Qâ‚ â‰¡ R âˆ§ Qâ‚‚`:
              (âˆ€ x â™ R â€¢ (âˆ€ y â™ Qâ‚ â€¢ P))
            â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
              (âˆ€ x, y â™ R âˆ§ Qâ‚ â€¢ P)
            â‰¡âŸ¨ Assumption â€œAâ€ âŸ©
              (âˆ€ x, y â™ R âˆ§ Qâ‚‚ â€¢ P)
            â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
              (âˆ€ x â™ R â€¢ (âˆ€ y â™ Qâ‚‚ â€¢ P))
      âŸ©
      (âˆ€ x â™ R â€¢ (âˆ€ y â™ Qâ‚ â€¢ P)) â‰¡ (âˆ€ x â™ R â€¢ (âˆ€ y â™ Qâ‚‚ â€¢ P))

MarkDown:
  In (8.22a) â€œChange of restricted dummyâ€, the antecedent is weaker than in (8.22) due to the additional range predicate;
  the theorem is therefore stronger, and is in fact what is really used where LADM refers to (8.22):

Theorem (8.22a) â€œChange of restricted dummyâ€:
  âˆ€ f â€¢ âˆ€ g â€¢
    (âˆ€ x â™ R â€¢ (âˆ€ y â€¢ x = f y  â‰¡  y = g x))
    â‡’ (  (âˆ€ x â™ R          â€¢ P         )
       â‰¡ (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y])
      )
Proof:
  For any `f`, `g`:
    Assuming â€œInverseâ€ `âˆ€ x â™ R â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x`:
        (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y])
      â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
        (âˆ€ y â™ R[x â‰” f y] â€¢ (âˆ€ x â™ x = f y â€¢ P))
      â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
        (âˆ€ y, x â™ R[x â‰” f y] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ y, x â™ R[x â‰” z][z â‰” f y] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œReplacementâ€ âŸ©
        (âˆ€ y, x â™ R[x â‰” z][z â‰” x] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ y, x â™ R âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œDummy list permutation for âˆ€â€ âŸ©
        (âˆ€ x, y â™ R âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ (âˆ€ y â™ x = f y â€¢ P))
      â‰¡âŸ¨ Subproof:
             âˆ€ x â™ R â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x    â€” This is assumption â€œInverseâ€
          â‡’âŸ¨ â€œRange replacement in nested âˆ€â€ âŸ©
             (âˆ€ x â™ R â€¢ (âˆ€ y â™ x = f y â€¢ P)) â‰¡ (âˆ€ x â™ R â€¢ (âˆ€ y â™ y = g x â€¢ P))
        âŸ©
        (âˆ€ x â™ R â€¢ (âˆ€ y â™ y = g x â€¢ P))
      â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ P[y â‰” g x])
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ x â™ R â€¢ P)

MarkDown:
  The proof above checks, but turning the subproof into a `with` would be nicer:
  ````
  Theorem (8.22a) â€œChange of restricted dummyâ€:
    (âˆ€ x â™ R â€¢ (âˆ€ y â€¢ x = f y  â‰¡  y = g x))
    â‡’ ((âˆ€ x â™ R â€¢ P) â‰¡ (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y]))
  Proof:
    Assuming â€œInverseâ€ `âˆ€ x â™ R â€¢ âˆ€ y â€¢ x = f y  â‰¡  y = g x`:
        (âˆ€ y â™ R[x â‰” f y] â€¢ P[x â‰” f y])
      â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
        (âˆ€ y â™ R[x â‰” f y] â€¢ (âˆ€ x â™ x = f y â€¢ P))
      â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
        (âˆ€ y, x â™ R[x â‰” f y] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ y, x â™ R[x â‰” z][z â‰” f y] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œReplacementâ€ âŸ©
        (âˆ€ y, x â™ R[x â‰” z][z â‰” x] âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ y, x â™ R âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œDummy list permutation for âˆ€â€ âŸ©
        (âˆ€ x, y â™ R âˆ§ x = f y â€¢ P)
      â‰¡âŸ¨ â€œNesting for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ (âˆ€ y â™ x = f y â€¢ P))
      â‰¡âŸ¨ â€œRange replacement in nested âˆ€â€ with assumption â€œInverseâ€ âŸ©
        (âˆ€ x â™ R â€¢ (âˆ€ y â™ y = g x â€¢ P))
      â‰¡âŸ¨ â€œOne-point rule for âˆ€â€ âŸ©
        (âˆ€ x â™ R â€¢ P[y â‰” g x])
      â‰¡âŸ¨ Substitution âŸ©
        (âˆ€ x â™ R â€¢ P)
  ````
  Unfortunately this does not check (as of 2018-10-12).

  #+end_src

** Sum Î£
   :PROPERTIES:
   :CUSTOM_ID: Sum-Î£
   :END:

 #+begin_src haskell
Axiom â€œLeibniz for âˆ‘ rangeâ€:
    (âˆ€ x â€¢ Râ‚ â‰¡ Râ‚‚) â‡’ (âˆ‘ x â™ Râ‚ â€¢ E) = (âˆ‘ x â™ Râ‚‚ â€¢ E)

Axiom â€œLeibniz for âˆ‘ bodyâ€:
    (âˆ€ x â€¢ R â‡’ Eâ‚ = Eâ‚‚) â‡’ (âˆ‘ x â™ R â€¢ Eâ‚) = (âˆ‘ x â™ R â€¢ Eâ‚‚)

Axiom (8.13) â€œEmpty range for âˆ‘â€:
  (âˆ‘ x â™ false â€¢ E)  =  0

Axiom (8.14) â€œOne-point rule for âˆ‘â€:
  (âˆ‘ x â™ x = D â€¢ E)  =  E[x â‰” D]

Axiom (8.15) â€œDistributivity of âˆ‘ over +â€:
  (âˆ‘ x â™ R â€¢ Eâ‚ + Eâ‚‚) = (âˆ‘ x â™ R â€¢ Eâ‚) + (âˆ‘ x â™ R â€¢ Eâ‚‚)

Axiom (8.17) â€œRange split for âˆ‘â€ â€œRange splitâ€:
     (âˆ‘ x â™ Q âˆ¨ R  â€¢ E)  +  (âˆ‘ x â™ Q âˆ§ R  â€¢ E)
   = (âˆ‘ x â™ Q      â€¢ E)  +  (âˆ‘ x â™ R      â€¢ E)

Theorem (8.16) â€œDisjoint range split for âˆ‘â€:
   (âˆ€ x â€¢ Q âˆ§ R â‰¡ false) â‡’
   ((âˆ‘ x â™ Q âˆ¨ R â€¢ E) = (âˆ‘ x â™ Q â€¢ E) + (âˆ‘ x â™ R â€¢ E))

Axiom (8.20) â€œNesting for âˆ‘â€:
    (âˆ‘ x â™ Q â€¢ (âˆ‘ y â™ R â€¢ E))
  = (âˆ‘ x, y â™ Q âˆ§ R â€¢ E)

Theorem â€œReplacement in âˆ‘â€:
    (âˆ‘ x â™ R âˆ§ e = f â€¢ E[y â‰” e])
  = (âˆ‘ x â™ R âˆ§ e = f â€¢ E[y â‰” f])

Axiom (8.20a) â€œDummy list permutation for âˆ‘â€:
   (âˆ‘ x, y â™ R â€¢ E) = (âˆ‘ y, x â™ R â€¢ E)

Theorem (8.19) â€œInterchange of dummiesâ€:
    (âˆ‘ x â™ Q â€¢ (âˆ‘ y â™ R â€¢ P))
  = (âˆ‘ y â™ R â€¢ (âˆ‘ x â™ Q â€¢ P))

Axiom (8.21) â€œDummy renaming for âˆ‘â€, â€œÎ±-conversionâ€:
  (âˆ‘ x â™ R â€¢ E) = (âˆ‘ y â™ R[x â‰” y] â€¢ E[x â‰” y])

Axiom â€œDistributivity of Â· over âˆ‘â€:
    a Â· (âˆ‘ x â™ R â€¢ E) = (âˆ‘ x â™ R â€¢ a Â· E)

Theorem â€œZero âˆ‘ bodyâ€: (âˆ‘ x â™ R â€¢ 0) = 0

Theorem â€œConstant range conjunction in âˆ‘â€:
    (âˆ‘ x â™ P âˆ§ R â€¢ F) = if P then (âˆ‘ x â™ R â€¢ F) else 0 fi

Theorem â€œConditional one-point rule for âˆ‘â€:
  (âˆ‘ x â™ P âˆ§ x = E â€¢ F) = if P[x â‰” E] then F[x â‰” E] else 0 fi
 #+end_src

** Sum Quantification for â„•                                    :Exercise:6_5:
   :PROPERTIES:
   :CUSTOM_ID: Sum-Quantification-for-â„•
   :END:

 #+begin_src haskell
Theorem â€œSplit off termâ€ â€œSplit off term at topâ€:
    (âˆ‘ i : â„• â™ i < suc n â€¢ E) = (âˆ‘ i : â„• â™ i < n â€¢ E) + E[i â‰” n]

Theorem â€œSplit off termâ€ â€œSplit off term at topâ€:
    m â‰¤ n â‡’
    (âˆ‘ i â™ m â‰¤ i < suc n â€¢ E) = (âˆ‘ i â™ m â‰¤ i < n â€¢ E) + E[i â‰” n]

Theorem â€œSplit off term at top using â‰¤â€:
    (âˆ‘ i â™ i â‰¤ suc n â€¢ E) = (âˆ‘ i â™ i â‰¤ n â€¢ E) + E[i â‰” suc n]

Theorem â€œOdd-number sumâ€:
    (âˆ‘ i : â„• â™ i < n â€¢ suc i + i) = n Â· n

Theorem â€œSum the numbersâ€:
    2 Â· (âˆ‘ i â™ i â‰¤ n â€¢ i) = n Â· suc n
 #+end_src

** Quantification Proofs: Monotonicity of Sum Quantification in â„• :Homework:12:
   :PROPERTIES:
   :CUSTOM_ID: Quantification-Proofs-Monotonicity-of-Sum-Quantification-in-â„•
   :END:
 #+begin_src haskell
Theorem â€œAddition is non-decreasingâ€: a â‰¤ a + b

Theorem â€œRange weakening for âˆ‘â€:
     (âˆ‘ x â™ Q â€¢ E) â‰¤ (âˆ‘ x â™ Q âˆ¨ R â€¢ E)

Theorem â€œRange weakening for âˆ‘â€:
    (âˆ‘ x â™ Q âˆ§ R â€¢ E) â‰¤ (âˆ‘ x â™ R â€¢ E)

Theorem â€œRange-monotonicity of âˆ‘â€:
     (âˆ€ x â€¢ Q â‡’ R) â‡’ ((âˆ‘ x â™ Q â€¢ E) â‰¤ (âˆ‘ x â™ R â€¢ E))

Theorem â€œBody increasing for âˆ‘â€:
    (âˆ‘ x â™ R â€¢ E) â‰¤ (âˆ‘ x â™ R â€¢ D + E)

Theorem â€œCancellation of monusâ€:  b â‰¤ a  â‡’  (a - b) + b = a

Theorem â€œBody-monotonicity of âˆ‘â€:
    (âˆ€ x â™ R â€¢ D â‰¤ E) â‡’ ((âˆ‘ x â™ R â€¢ D) â‰¤ (âˆ‘ x â™ R â€¢ E))
 #+end_src

** Practice with Universal and Existential Quantification in the setting of â„• :Homework:11_2:
   :PROPERTIES:
   :CUSTOM_ID: Practice-with-Universal-and-Existential-Quantification-in-the-setting-of-â„•
   :END:
 #+begin_src haskell
Theorem â€œUnboundedness of â„•â€: âˆ€ n : â„• â€¢ âˆƒ m : â„• â€¢ n < m

Theorem â€œUnboundedness of â„•â€: âˆ€ n : â„• â€¢ âˆƒ m : â„• â€¢ n < m

Theorem â€œAddition does not associate mutually with monusâ€:
  Â¬ (âˆ€ k : â„• â€¢ âˆ€ m : â„• â€¢ âˆ€ n : â„• â€¢ k + (m - n) = (k + m) - n)
 #+end_src
* Reverse Correctness Presentation :Homework_5_1:
  :PROPERTIES:
  :CUSTOM_ID: Reverse-Correctness-Presentation
  :END:

  In lecture and in the homework, we have stressed that assignment command
  calculations should â€˜begin at the bottomâ€™ and work up; as such, it is more
  â€˜naturalâ€™ to begin our calculation with the â€˜bottom partâ€™ at the top and work
  our way down to the other part.

  To do so, we use the â€˜flipped aroundâ€™ assignment connective:

#+begin_src haskell
    Axiom â€œDefinition of â…_â†â‡â€:   Q â… C â†â‡ P  â‰¡  P â‡’â… C â† Q
#+end_src

  This is similar to the arithmetic ordering:

#+begin_src haskell
    y â‰¥ x  â‰¡  x â‰¤ y
#+end_src

  It is the same thing, but the order has been flipped to make writing our
  calculations the same way we actually think of them: With the post-condition
  first, then eventually obtaining the pre-condition.

  Here is a demonstration...

#+begin_src haskell
     Lemma â€œDemoâ€: x + y = 13    â‡’â… x := x + 7 â†   x + y = 20
     Proof:
         x + y = 20
       â… x := x + 7 â†â‡ âŸ¨ â€œAssignmentâ€ âŸ©
         (x + y = 20)[x â‰” x + 7]
       â‰¡âŸ¨ Substitution âŸ©
         x + 7 + y = 20
       â‰¡âŸ¨ Fact `20 = 13 + 7` âŸ©
         x + 7 + y = 13 + 7
       â‰¡âŸ¨ â€œCancellation of +â€ âŸ©
         x + y = 13
  #+end_src

  This â€˜flipped aroundâ€™ notation is only superficial, and
  so it also applies to sequential commands, as follows.
#+begin_src haskell
     Lemma â€œDemoâ€:  j + k = S
                   â‡’â… j  := j + 1â® k := k + 1 â†
                    j + k = S + 2
     Proof:
         j + k = S + 2
       â… k := k + 1 â†â‡âŸ¨ â€œAssignmentâ€ âŸ©
         (j + k = S + 2)[k â‰” k + 1]
       â‰¡âŸ¨ Substitution âŸ©
          j + k + 1 = S + 2
       â… j := j + 1 â†â‡âŸ¨ â€œAssignmentâ€ âŸ©
         (j + k + 1 = S + 2)[j â‰” j + 1]
       â‰¡âŸ¨ Substitution â€” and sym & assoc of + âŸ©
         j + k + 1 + 1 = S + 2
       â‰¡âŸ¨ Fact `1 + 1 = 2` âŸ©
         j + k + 2 = S + 2
       â‰¡âŸ¨ â€œCancellation of +â€ âŸ©
         j + k = S
#+end_src

  **Note** that the seqence of the assignment in the proof is â€œalong the â‡ arrowsâ€,
  that is, if you are reading and/or writing top-down,
  you encounter the last assignment first!

  #+begin_src haskell
Lemma â€œSetâ€: true â‡’â… p := q â† (p â‰¡ q)

Lemma â€œIncrementâ€: x = 0  â‡’â… x := x + q â†   x = q

Lemma â€œStay Simpleâ€:   q = a Â· c
                      â‡’â… q := q + c Â· c â® a := a + c  â†
                       q = a Â· c

Lemma â€œSquare Sucâ€: (n + 1) Â· (n + 1) = n Â· n + 2 Â· n + 1

Lemma â€œStay squaredâ€:   s = n Â· n
                      â‡’â… s := s + 2 Â· n + 1â® n := n + 1 â†
                        s = n Â· n
#+end_src

* Residuals                                                             :Assignment:3:
  :PROPERTIES:
  :CUSTOM_ID: Residuals
  :END:

# Residuals: Integer Division and Boolean Implication

** Implication is â€œdivisionâ€ for the Booleans ... !?
   :PROPERTIES:
   :CUSTOM_ID: Implication-is-division-for-the-Booleans
   :END:

  #+begin_src haskell
Declaration: _Ã·_ : â„• â†’ â„• â†’ â„•   â•â•â•  \div
Axiom â€œCharacterisation of Ã·â€:  k Â· m â‰¤ n  â‰¡  k â‰¤ n Ã· m

Theorem â€œSub-cancellation of Ã·â€:  (a Ã· b) Â· b â‰¤ a

Theorem â€œCharacterisation of â‡â€:  (k âˆ§ m) â‡’ n  â‰¡  k â‡’ (n â‡ m)

Theorem â€œCharacterisation of â‡’â€:  (k âˆ§ m) â‡’ n  â‰¡  k â‡’ (m â‡’ n)

Theorem â€œSub-cancellation of â‡â€:  (a â‡ b) âˆ§ b   â‡’   a

Declaration: _ï¼_ : Ï„ â†’ Ï„ â†’ Ï„  â•â•â•  â€œoverâ€, \over
Declaration: _ï¼¼_ : Ï„ â†’ Ï„ â†’ Ï„  â•â•â•  â€œunderâ€, \under
Declaration: _â¨¾_ : Ï„ â†’ Ï„ â†’ Ï„   â•â•â•  â€œand thenâ€, \;;
Declaration: Id : Ï„           â•â•â•   â€œidentityâ€

Axiom â€œAssociativity of â¨¾â€:  (x â¨¾ y) â¨¾ z  =  x â¨¾ (y â¨¾ z)
Axiom â€œLeft-identity of â¨¾â€:  Id â¨¾ x = x
Axiom â€œRight-Identity of â¨¾â€: x â¨¾ Id = x

Axiom â€œCharacterisation of ï¼â€:  a â¨¾ b âŠ‘ c  â‰¡  a âŠ‘ c ï¼ b
Axiom â€œCharacterisation of ï¼¼â€:  a â¨¾ b âŠ‘ c  â‰¡  b âŠ‘ a ï¼¼ c

Theorem â€œCancellation of ï¼â€: (a ï¼ b) â¨¾ b âŠ‘ a

Theorem â€œCancellation of ï¼¼â€: a â¨¾ (a ï¼¼ b) âŠ‘ b
#+end_src

** Enriched Indirect Reasoning
   :PROPERTIES:
   :CUSTOM_ID: Enriched-Indirect-Reasoning
   :END:
#+begin_src haskell
Theorem â€œEnriched indirect equalityâ€ â€œIndirect equalityâ€:
   P[z â‰” x] âˆ§ P[z â‰” y]
   â‡’  ((âˆ€ z â™ P â€¢ z âŠ‘ x â‰¡ z âŠ‘ y)  â‰¡  x = y)

Theorem  â€œIndirect equalityâ€: (âˆ€ z â€¢ z âŠ‘ x â‰¡ z âŠ‘ y)  â‰¡  x = y

Theorem  â€œIndirect equalityâ€: (âˆ€ z â€¢ z â‰¤ x â‰¡ z â‰¤ y)  â‰¡  x = y

Theorem  â€œIndirect equalityâ€: (âˆ€ z â€¢ z â‡’ x  â‰¡  z â‡’ y)  â‰¡  x = y

Theorem â€œDividing a divisionâ€: (a Ã· b) Ã· c  =  a Ã· (c Â· b)

Theorem â€œDividing a divisionâ€: ((a â‡ b) â‡ c)  =  (a â‡ (c âˆ§ b))

Theorem â€œDividing a divisionâ€: (a ï¼ b) ï¼ c  =  a ï¼ (c â¨¾ b)

Theorem â€œDividing a divisionâ€: a ï¼¼ (b ï¼¼ c)  =  (b â¨¾ a) ï¼¼ c

Theorem â€œArchimedian Propertyâ€: âˆ€ m â€¢ âˆ€ n â€¢ âˆƒ k â€¢  m Â· k  â‰¤  n
#+end_src

** A meaning of â€œgroupsâ€ âŠ•, â¨¾, Ë˜, â»Â¹; â€œlatticesâ€ âŠ‘, âŠ“, âŠ”; â€œresidualsâ€ â•±, â•²
   :PROPERTIES:
   :CUSTOM_ID: A-meaning-of-groups-lattices-residuals
   :END:

  Before continuing, you may have seen _âŠ‘_ as a placeholder (metavariable,
  abstraction) of notions of order that you may come to see later in your CS studies, such
  as at-most â‰¤, divisibility âˆ£, set-inclusion âŠ†, structure-inclusion (graphs,
  etc), program-refinement, propositional strength â‡’.

  We can make the following â€œinterpretationâ€:

    | Symbol      | Clothes Interpretation                                                                                |
    | ğ“           | Putting on the article of clothing ğ“                                                                  |
    | x Ë˜, or xâ»Â¹ | Taking off the article of clothing ğ“ âŸ¦ Maybe you see _Ë˜ in A4. âŸ§                                      |
    | ğ“ â¨¾ ğ“       | (â€œâŠ•â€) Wearing clothes ğ“ â€œand thenâ€ wearing ğ“ ---e.g., socks then shoes                                |
    | ğ“ â»Â¹ â¨¾ ğ“ â»Â¹ | â€œTaking offâ€ clothesâ€ ğ“ and then â€œtaking offâ€ ğ“ ---e.g., shoes off then socks off                     |
    | ğ“ âŠ‘ ğ“       | The articles of clothes ğ“ â€œcan be found amongâ€ the pile of clothes ğ“                                  |
    | ğ“ âŠ“ ğ“       | The accessories needed for â€œbothâ€ kinds of clothes ğ“ and ğ“                                            |
    | ğ“ âŠ” ğ“       | Possible accessories, clothes, that go well with clothes ğ“ â€œorâ€ clothes ğ“                             |
    | ğ“ â•± ğ“       | Wear as much clothes as possible â€œand-thenâ€ wear ğ“, so the wardrobe is in the pile of clothes ğ“       |
    | ğ“ â•² ğ“       | Wear ğ“ â€œfirst and-thenâ€ wear as much clothes as possible, so the wardrobe is in the pile of clothes ğ“ |

** Monotonicity and Strengthening Proofs
   :PROPERTIES:
   :CUSTOM_ID: Monotonicity-and-Strengthening-Proofs
   :END:
#+begin_src haskell
Theorem â€œCancellation of ï¼â€: (a ï¼ b) â¨¾ b âŠ‘ a

Theorem â€œCancellation of ï¼¼â€: a â¨¾ (a ï¼¼ b) âŠ‘ b

Theorem â€œCancellation by ï¼â€ â€œRight-division of multiplesâ€: a âŠ‘ (a â¨¾ b) ï¼ b

Theorem â€œCancellation by ï¼¼â€ â€œLeft-division of multiplesâ€: b âŠ‘ a ï¼¼ (a â¨¾ b)

Theorem â€œMonotonicity of â¨¾â€: a âŠ‘ aâ€² â‡’ a â¨¾ b âŠ‘ aâ€² â¨¾ b

Theorem â€œMonotonicity of â¨¾â€: b âŠ‘ bâ€² â‡’ a â¨¾ b âŠ‘ a â¨¾ bâ€²

Theorem â€œMonotonicity of â¨¾â€: a âŠ‘ aâ€² âˆ§ b âŠ‘ bâ€² â‡’ a â¨¾ b âŠ‘ aâ€² â¨¾ bâ€²

Theorem â€œNumerator monotonicityâ€: a âŠ‘ aâ€² â‡’  a ï¼ b âŠ‘ aâ€² ï¼ b

Theorem â€œNumerator monotonicityâ€: b âŠ‘ bâ€² â‡’  a ï¼¼ b âŠ‘ a ï¼¼ bâ€²

Theorem â€œDenominator antitonicityâ€: bâ€² âŠ‘ b â‡’  a ï¼ b âŠ‘ a ï¼ bâ€²

Theorem â€œDenominator antitonicityâ€: aâ€² âŠ‘ a â‡’  a ï¼¼ b âŠ‘ aâ€² ï¼¼ b
#+end_src

* Set Theory                                                    :Homework_15:
  :PROPERTIES:
  :CUSTOM_ID: Set-Theory
  :END:

  Set theory is based on the membership relation ~_âˆˆ_~ (type ~\in~).

  In typed set theory, we also have, for each type ~t~,
  a separate type ~set t~ for **sets with elements of type t**.

  A membership relationship â€œx âˆˆ Sâ€ then only makes sense of an ~x~ of type ~t~
  if ~S~ is of type ~set t~.
  This is formalised by giving ~_âˆˆ_~ the type ~t â†’ set t â†’ ğ”¹~,
  where ~t~ is a type variable (as in the typing of equality, ~_=_ : t â†’ t â†’ ğ”¹~):

# Theorem â€œNon-empty setsâ€: S â‰  {} â‰¡ (âˆƒ x â€¢ x âˆˆ S)

#+begin_src haskell
Declaration: set : Type â†’ Type

Declaration: ğ” : set t

Declaration: _âˆˆ_ : t â†’ set t â†’ ğ”¹
Explanation: e âˆˆ S â‰” â€œ`e` is an element of `S`.â€
Explanation: e âˆˆ S â‰” â€œitem `e` is an element of the set `S`.â€

Axiom (11.4) â€œSet extensionalityâ€:
   S = T  â‰¡  (âˆ€ e  â€¢  e âˆˆ S  â‰¡  e âˆˆ T)
#+end_src
** Inclusion
   :PROPERTIES:
   :CUSTOM_ID: Inclusion
   :END:
#+begin_src haskell
Declaration: _âŠ†_ : set t â†’ set t â†’ ğ”¹

Axiom (11.13) â€œSubsetâ€ â€œDefinition of âŠ†â€ â€œSet inclusionâ€:
   S âŠ† T  â‰¡  (âˆ€ e â™ e âˆˆ S â€¢ e âˆˆ T)

Corollary â€œSubsetâ€ â€œDefinition of âŠ†â€ â€œSet inclusionâ€:
   S âŠ† T  â‰¡  (âˆ€ e â€¢ e âˆˆ S â‡’ e âˆˆ T)

Theorem â€œSubset membershipâ€ â€œCastingâ€:
    X âŠ† Y â‡’ x âˆˆ X â‡’ x âˆˆ Y

Theorem (11.59) â€œTransitivity of âŠ†â€: X âŠ† Y â‡’ Y âŠ† Z â‡’ X âŠ† Z

Theorem (11.58) â€œReflexivity of âŠ†â€: X âŠ† X

Theorem (11.57) â€œAntisymmetry of âŠ†â€: X âŠ† Y â‡’ Y âŠ† X â‡’ X = Y

Theorem (11.57) â€œAntisymmetry of âŠ†â€: X âŠ† Y â‡’ Y âŠ† X â‡’ X = Y

Theorem (11.57) â€œAntisymmetry of âŠ†â€: X âŠ† Y â‡’ Y âŠ† X â‡’ X = Y
#+end_src
** Complement
   :PROPERTIES:
   :CUSTOM_ID: Complement
   :END:

  The *complement* of a set ~S~, written ~~ S~, is the collection of elements that are not in
  ~S~.

#+begin_src haskell
Declaration: ~_ : set t â†’ set t

Axiom â€œComplementâ€: e âˆˆ ~ S  â‰¡ Â¬ (e âˆˆ S)

Theorem (11.19) â€œSelf-inverse of complementâ€: ~ (~ S) = S

Theorem â€œLower ~ connection for âŠ†â€:
    ~ X âŠ† Y  â‰¡  ~ Y âŠ† X

Theorem â€œUpper ~ connection for âŠ†â€:
    X âŠ† ~ Y  â‰¡  Y âŠ† ~ X
#+end_src
** Union and Intersection
   :PROPERTIES:
   :CUSTOM_ID: Union-and-Intersection
   :END:
#+begin_src haskell
Declaration: _âˆª_ , _âˆ©_ : set t â†’ set t â†’ set t

Axiom â€œUnionâ€:          e âˆˆ S âˆª T  â‰¡  e âˆˆ S  âˆ¨  e âˆˆ T
Axiom â€œIntersectionâ€:   e âˆˆ S âˆ© T  â‰¡  e âˆˆ S  âˆ§  e âˆˆ T

Theorem (11.45) â€œInclusion via âˆªâ€:  S âŠ† T  â‰¡  S âˆª T = T
#+end_src

** Pairs and Cartesian Products
   :PROPERTIES:
   :CUSTOM_ID: Pairs-and-Cartesian-Products
   :END:

   The pair consisting of the two constituents `b` and `c`, in that order, is written `âŸ¨ b , c âŸ©`.

   Pairs are equal exactly if their respective constituents are equal:

 #+begin_src haskell
Axiom (14.2) â€œPair equalityâ€: âŸ¨ b, c âŸ© =  âŸ¨ b', c' âŸ©  â‰¡  b = b' âˆ§ c = c'
 #+end_src

   If `t` and `u` are types,
   the type of pairs with first constituent in `t` and second constituent in `u`
   is written `â° t, u â±`. (You type `\<!` for `â°` and `\>!` for `â±`, but you will probably not need these a lot.)

   The pair projections for pairs with any constituent types:

 #+begin_src haskell
Declaration: fst : â° t , u â± â†’ t
Declaration: snd : â° t , u â± â†’ u

Axiom â€œDefinition of `fst`â€: fst âŸ¨ x, y âŸ© = x
Axiom â€œDefinition of `snd`â€: snd âŸ¨ x, y âŸ© = y

Axiom â€œPair equalityâ€: p = q  â‰¡  fst p = fst q  âˆ§  snd p = snd q
 #+end_src
 We use `_Ã—_` for Cartesian product of **sets** only, not for types:

 #+begin_src haskell
Declaration: _Ã—_ : set t â†’ set u â†’ set â° t , u â±

Axiom â€œMembership in Ã—â€:
  p âˆˆ S Ã— T  â‰¡  fst p âˆˆ S âˆ§ snd p âˆˆ T

Theorem (14.4) â€œMembership in Ã—â€:
    âŸ¨ x , y âŸ© âˆˆ S Ã— T  â‰¡  x âˆˆ S âˆ§ y âˆˆ T

Theorem â€œPair extensionalityâ€: p = âŸ¨ fst p , snd p âŸ©

Theorem (14.5) â€œMembership in swapped Ã—â€:
    âŸ¨ x , y âŸ© âˆˆ S Ã— T  â‰¡  âŸ¨ y , x âŸ© âˆˆ T Ã— S

Theorem (14.6) â€œEmpty factor in Ã—â€:
    S = {}  â‡’  S Ã— T = {}

Declaration: swap-Ã— : â° t, u â± â†’ â° u, t â±
Axiom â€œDefinition of `swap-Ã—`â€: swap-Ã— âŸ¨ x, y âŸ© = âŸ¨ y, x âŸ©

Theorem â€œfst after swap-Ã—â€: fst (swap-Ã— p) = snd p

Theorem â€œsnd after swap-Ã—â€: snd (swap-Ã— p) = fst p
 #+end_src

* Relations
  :PROPERTIES:
  :CUSTOM_ID: Relations
  :END:
** Relations via Set Theory                                     :Homework:17:
   :PROPERTIES:
   :CUSTOM_ID: Relations-via-Set-Theory
   :END:

*** Domain and Range
    :PROPERTIES:
    :CUSTOM_ID: Domain-and-Range
    :END:
 #+begin_src haskell
Declaration:  Dom : (A â†” B) â†’ set A
Declaration:  Ran : (A â†” B) â†’ set B

Axiom â€œMembership in `Dom`â€:
  x âˆˆ Dom R  â‰¡  âˆƒ y â€¢ x â¦— R â¦˜ y

Axiom â€œMembership in `Ran`â€:
  y âˆˆ Ran R  â‰¡  âˆƒ x â€¢ x â¦— R â¦˜ y

Theorem â€œDomain of unionâ€: Dom (R âˆª S) = Dom R âˆª Dom S

Theorem â€œDomain of intersectionâ€: Dom (R âˆ© S) âŠ† Dom R âˆ© Dom S
 #+end_src
*** Relation Converse
    :PROPERTIES:
    :CUSTOM_ID: Relation-Converse
    :END:
 #+begin_src haskell
Declaration: _Ë˜ : (A â†” B) â†’ (B â†” A)

Axiom â€œRelation converseâ€ â€œRelationship via Ë˜â€:
    y â¦— R Ë˜ â¦˜ x  â‰¡  x â¦— R â¦˜ y

Theorem â€œSelf-inverse of Ë˜â€:   R Ë˜ Ë˜  =  R

Theorem â€œMonotonicity of Ë˜â€: R âŠ† S      â‡’  R Ë˜ âŠ† S Ë˜

Theorem â€œIsotonicity of Ë˜â€: R âŠ† S   â‰¡   R Ë˜ âŠ† S Ë˜

Theorem â€œDomain of converseâ€: Dom (R Ë˜) = Ran R

Theorem â€œConverse of âˆ©â€:     (R âˆ© S) Ë˜  =  R Ë˜ âˆ© S Ë˜
 #+end_src
*** Relation Composition
    :PROPERTIES:
    :CUSTOM_ID: Relation-Composition
    :END:
 #+begin_src haskell
Declaration: _â¨¾_ : (A â†” B) â†’ (B â†” C) â†’ (A â†” C)

Axiom â€œRelation compositionâ€:
    a â¦— R â¨¾ S â¦˜ c  â‰¡  âˆƒ b â€¢ a â¦— R â¦˜ b âˆ§ b â¦— S â¦˜ c

Theorem â€œConverse of â¨¾â€:    (R â¨¾ S) Ë˜    =  S Ë˜ â¨¾ R Ë˜
 #+end_src
*** Polymorphic Identity
    :PROPERTIES:
    :CUSTOM_ID: Polymorphic-Identity
    :END:

   The only new item introduced in this section is the polymorphic identity relation ~Id~.

   Similar to how equality ~_=_~ can be used at type ~A â†’ A â†’ ğ”¹~ for any type ~A~,
   this new ~Id~ can be used at type ~A â†” A~ at any type ~A~:

 #+begin_src haskell
Declaration: Id : A â†” A
 #+end_src



   The lecture slides present ~Id~ as abbreviation for ~ğ•€ ğ”~.

   (Remember that the blackboard-bold I symbol ~ğ•€~ is obtained by typing ~\II~,
   two upper-case i letters as in identity.)

   Where this is used at type ~A â†” A~,
   it has also been written informally on the lecture slides as ~ğ•€ âŒ A âŒŸ~,
   using the convention that ~âŒ A âŒŸ~ stands for ~ğ” : set A~.

 #+begin_src haskell
Axiom â€œDefinition of `Id` via ğ•€â€: Id = ğ•€ ğ”
 #+end_src

   With that, the direct correspondence between `Id` and `_=_` is easy to derive,
   and does not need to mention the type (that is, the â€œ`A`â€ mentioned so far):


 #+begin_src haskell
Theorem â€œIdentity relationâ€ â€œRelationship via `Id`â€:
    x â¦— Id â¦˜ y  â‰¡  x = y

Theorem â€œConverse of `Id`â€: Id Ë˜        =  Id

Theorem â€œLeft-identity of â¨¾â€ â€œIdentity of â¨¾â€:
    Id â¨¾ R = R

Theorem â€œRight-identity of â¨¾â€ â€œIdentity of â¨¾â€:
    R â¨¾ Id = R
 #+end_src
*** Reflexivity
    :PROPERTIES:
    :CUSTOM_ID: Reflexivity
    :END:
 We define the reflexivity predicate for relations using the predicate-logic formulation:
    #+begin_src haskell
Declaration: reflexive : A â†” A  â†’  ğ”¹
Axiom â€œDefinition of reflexivityâ€:  reflexive R  â‰¡  âˆ€ x â€¢ x â¦— R â¦˜ x

Theorem â€œ`Id` is reflexiveâ€: reflexive Id

Theorem â€œReflexivityâ€:  reflexive R  â‰¡  Id âŠ† R

Theorem â€œComposition of reflexive relationsâ€:
  reflexive R â‡’ reflexive S â‡’ reflexive (R â¨¾ S)

Theorem â€œConverse of reflexive relationsâ€:
  reflexive R â‡’ reflexive (R Ë˜)

Theorem â€œConverse reflects reflectivityâ€:
  reflexive (R Ë˜) â‡’ reflexive R
 #+end_src
*** Transitivity
    :PROPERTIES:
    :CUSTOM_ID: Transitivity
    :END:
   We define the transitivity predicate for relations using the predicate-logic formulation:
 #+begin_src haskell
Declaration: transitive : A â†” A  â†’  ğ”¹
Axiom â€œDefinition of transitivityâ€:
    transitive R   â‰¡  âˆ€ x â€¢ âˆ€ y â€¢ âˆ€ z â€¢
                        x â¦— R â¦˜ y â¦— R â¦˜ z  â‡’  x â¦— R â¦˜ z

Theorem â€œConverse of transitive relationsâ€:
    transitive R â‡’ transitive (R Ë˜)
 #+end_src

** Relations via Set Theory I: Properties of the Basic Operators :Exercise:10_1:
   :PROPERTIES:
   :CUSTOM_ID: Relations-via-Set-Theory-I-Properties-of-the-Basic-Operators
   :END:

   #+begin_src haskell
Theorem â€œConverse of {}â€:     {} Ë˜  =  {}

Theorem â€œConverse of âˆªâ€:     (R âˆª S) Ë˜  =  R Ë˜ âˆª S Ë˜

Theorem â€œDistributivity of â¨¾ over âˆª to the rightâ€
        â€œDistributivity of â¨¾ over âˆªâ€:
    Q â¨¾ (R âˆª S)  =  Q â¨¾ R  âˆª  Q â¨¾ S

Theorem â€œSub-distributivity of â¨¾ over âˆ© to the rightâ€
        â€œSub-distributivity of â¨¾ over âˆ©â€:
     Q â¨¾ (R âˆ© S)  âŠ†  Q â¨¾ R  âˆ©  Q â¨¾ S

Theorem â€œAssociativity of â¨¾â€: (Q â¨¾ R) â¨¾ S = Q â¨¾ (R â¨¾ S)

Theorem â€œMonotonicity of â¨¾ in first argumentâ€ â€œMonotonicity of â¨¾â€:
    Q âŠ† R  â‡’  Q â¨¾ S âŠ† R â¨¾ S

Theorem â€œMonotonicity of â¨¾ in second argumentâ€ â€œMonotonicity of â¨¾â€:
    R âŠ† S  â‡’  Q â¨¾ R âŠ† Q â¨¾ S

Theorem â€œCharacterisation of âˆ©â€:
    Q âŠ† R âˆ© S   â‰¡   Q âŠ† R  âˆ§ Q âŠ† (S : A â†” B)
 #+end_src

   The modal rule can be seen as a kind of over-approximation
   of multiplicative inverse with respect to composition â€œ~â¨¾~â€.

   In a field, for example in â„, if ~a~ has an inverse ~aâ»Â¹~
   (that is, if ~a Â· aâ»Â¹ = 1~, which requires ~a â‰  0~),
   then you have:

   #+begin_src haskell
      a Â· b + c  =  a Â· (b + aâ»Â¹ Â· c)
   #+end_src
   Relation converse in general does not produce inverses,
   but still an â€œover-approximation to an inverseâ€,
   since the equation above turns into a relation inclusion:

   #+begin_src haskell
Theorem â€œModal ruleâ€:    (Q â¨¾ R) âˆ© S âŠ† Q â¨¾ (R âˆ© Q Ë˜ â¨¾ S)

Theorem â€œModal ruleâ€:    (Q â¨¾ R) âˆ© S âŠ† (Q âˆ© S â¨¾ R Ë˜) â¨¾ R

Theorem â€œRestricted identity property for ğ•€-Domâ€:
     ğ•€ (Dom R) â¨¾ R = R
 #+end_src

** Relations via Set Theory II: Properties of the Basic Operators :Exercise:10_2:
   :PROPERTIES:
   :CUSTOM_ID: Relations-via-Set-Theory-II-Properties-of-the-Basic-Operators
   :END:
 #+begin_src haskell
Declaration: P : Type
Explanation: P â‰” â€œType of personsâ€

  We declare relations `C` and `B` with the following meanings:

  - `p â¦— C â¦˜ q` means â€œ`p` called `q` (by phone)â€
  - `p â¦— B â¦˜ q` means â€œ`p` is a brother of `q`â€

Declaration: C : P â†” P
Declaration: B : P â†” P

Declaration: Helen, Aos, Jun, Obama, Shirley, Alex, Jim, Jane : P

### Relationship to Predicate Logic

  From the following relationship statements,
  calculate â€œreadableâ€ predicate logic statements:

Calculation:
    Aos â¦— C â¨¾ B â¦˜ Jun

Calculation:
    Aos â¦— ~ (C â¨¾ ~ B) â¦˜ Jun

Calculation:
    Aos â¦— ~ (~ C â¨¾ B) â¦˜ Jun

Calculation:
    Aos â¦— ~ ((C âˆ© ~ (B â¨¾ C Ë˜)) â¨¾ ~ B) â¦˜ Jun

Calculation:
    (B â¨¾ ({ Jun } Ã— ğ”)) âˆ© (C â¨¾ C Ë˜)  âŠ†  Id

### Formalise Relation-Algebraically

Axiom â€œHelen called somebody who called herâ€: ?

Axiom â€œAos called everybody who called a brother of Junâ€: ?

Axiom â€œAos hasn't called anybody who has called Junâ€: ?
 #+end_src

** Relations via Set Theory: Counterexamples for Non-Properties of the Basic Operators :Exercise:10_3:
   :PROPERTIES:
   :CUSTOM_ID: Relations-via-Set-Theory-Counterexamples-for-Non-Properties-of-the-Basic-Operators
   :END:
 #+begin_src haskell
Lemma â€œMembership in two-element set enumerationâ€: x âˆˆ {x, y}
Lemma â€œMembership in set enumerationâ€: x âˆˆ {u â™ u = x âˆ¨ R}

Theorem â€œNon-Isotonicity of â¨¾ in first argumentâ€:
    Â¬(âˆ€ Q : ğ”¹ â†” ğ”¹ â€¢ âˆ€ R : ğ”¹ â†” ğ”¹ â€¢ âˆ€ S : ğ”¹ â†” ğ”¹
      â€¢ Q â¨¾ S âŠ† R â¨¾ S  â‡’  Q âŠ† R)

Theorem â€œNon-distributivity of â¨¾ over âˆ© to the rightâ€:
    Â¬ (âˆ€ Q : ğ”¹ â†” ğ”¹ â€¢ âˆ€ R : ğ”¹ â†” ğ”¹ â€¢ âˆ€ S : ğ”¹ â†” ğ”¹ â€¢ Q â¨¾ R  âˆ©  Q â¨¾ S  âŠ†  Q â¨¾ (R âˆ© S))
 #+end_src

** Relations via Set Theory: Heterogeneous Relation Properties, starting from Relation-Algebraic Formulations :Homework:18:
   :PROPERTIES:
   :CUSTOM_ID: Relations-via-Set-Theory-Heterogeneous-Relation-Properties-starting-from-Relation-Algebraic-Formulations
   :END:
 #+begin_src haskell
Theorem â€œMonotonicity of âˆªâ€: Aâ‚ âŠ† Aâ‚‚ â‡’ (Aâ‚ âˆª B) âŠ† (Aâ‚‚ âˆª B)

Theorem â€œMonotonicity of âˆªâ€: Aâ‚ âŠ† Aâ‚‚ â‡’ Bâ‚ âŠ† Bâ‚‚ â‡’ (Aâ‚ âˆª Bâ‚) âŠ† (Aâ‚‚ âˆª Bâ‚‚)

Theorem â€œDistributivity of â¨¾ over âˆª to the leftâ€
        â€œDistributivity of â¨¾ over âˆªâ€:
    (Q âˆª R) â¨¾ S  =  Q â¨¾ S  âˆª  R â¨¾ S
 #+end_src
*** Univalence
    :PROPERTIES:
    :CUSTOM_ID: Univalence
    :END:

   A relation is univalent iff it relates each argument with at most one result.
 #+begin_src haskell
Declaration: is-univalent : A â†” B  â†’  ğ”¹
Axiom â€œDefinition of univalenceâ€:    is-univalent R   â‰¡  R Ë˜ â¨¾ R âŠ† Id

Theorem â€œUnivalence of compositionâ€:
     is-univalent R â‡’ is-univalent S â‡’ is-univalent (R â¨¾ S)

Theorem â€œUnivalenceâ€:
      is-univalent R
   â‰¡  âˆ€ bâ‚ â€¢ âˆ€ bâ‚‚ â€¢ âˆ€ a â€¢ a â¦— R â¦˜ bâ‚ âˆ§ a â¦— R â¦˜ bâ‚‚ â‡’ bâ‚ = bâ‚‚
 #+end_src
*** Totality
    :PROPERTIES:
    :CUSTOM_ID: Totality
    :END:
   A relation is total if it relates each argument with at least one result.
 #+begin_src haskell
Declaration: is-total : A â†” B  â†’  ğ”¹
Axiom â€œDefinition of totalityâ€:      is-total R       â‰¡  Id âŠ† R â¨¾ R Ë˜

Theorem â€œTotality of unionâ€:
    is-total R â‡’ is-total S â‡’ is-total (R âˆª S)

Theorem â€œTotalityâ€: is-total R  â‰¡  âˆ€ a â€¢ âˆƒ b â€¢ a â¦— R â¦˜ b

Theorem â€œDomain of total relationsâ€:   is-total R  â‰¡  ğ” âŠ† Dom R

Theorem â€œDomain of total relationsâ€:  is-total R  â‰¡  Dom R = ğ”
 #+end_src
*** Injectivity
    :PROPERTIES:
    :CUSTOM_ID: Injectivity
    :END:
 #+begin_src haskell
Declaration: is-injective : A â†” B  â†’  ğ”¹

Axiom â€œDefinition of injectivityâ€:
    is-injective R    â‰¡   R â¨¾ R Ë˜  âŠ†  Id
 #+end_src
   Injectivity is dual (with respect to the direction of composition)
   to univalence, so the dualisation operator â€œ`_Ë˜`â€ (converse)
   converts between the two:
 #+begin_src haskell
Theorem â€œInjectivity of converseâ€:
    is-injective (R Ë˜) â‰¡  is-univalent R

Theorem â€œUnivalence of converseâ€:
    is-univalent (R Ë˜)  â‰¡  is-injective R

Theorem â€œInjectivityâ€:
       is-injective R
    â‰¡  âˆ€ aâ‚ â€¢ âˆ€ aâ‚‚ â€¢ âˆ€ b â€¢ aâ‚ â¦— R â¦˜ b âˆ§ aâ‚‚ â¦— R â¦˜ b â‡’ aâ‚ = aâ‚‚
 #+end_src
*** Surjectivity
    :PROPERTIES:
    :CUSTOM_ID: Surjectivity
    :END:
 #+begin_src haskell
Declaration: is-surjective : A â†” B  â†’  ğ”¹

Axiom â€œDefinition of surjectivityâ€:
    is-surjective R    â‰¡   Id  âŠ†  R Ë˜ â¨¾ R

Theorem â€œTotality of converseâ€:
    is-total (R Ë˜)  â‰¡  is-surjective R

Theorem â€œSurjectivityâ€:
    is-surjective R  â‰¡  (âˆ€ b â€¢ (âˆƒ a â€¢ a â¦— R â¦˜ b))
 #+end_src

** Cartesian Products and Relations
   :PROPERTIES:
   :CUSTOM_ID: Cartesian-Products-and-Relations
   :END:
 #+begin_src haskell
Lemma â€œRelationship via Ã—â€: x â¦— S Ã— T â¦˜ y  â‰¡  x âˆˆ S âˆ§ y âˆˆ T

Theorem (14.8) â€œDistributivity of Ã— over âˆªâ€:
    S Ã— (T âˆª U) = (S Ã— T) âˆª (S Ã— U)

Theorem (14.8) â€œDistributivity of Ã— over âˆªâ€:
    (S âˆª T) Ã— U = (S Ã— U) âˆª (T Ã— U)

Theorem (14.9) â€œDistributivity of Ã— over âˆ©â€:
    S Ã— (T âˆ© U) = (S Ã— T) âˆ© (S Ã— U)

Theorem (14.9) â€œDistributivity of Ã— over âˆ©â€:
    (S âˆ© T) Ã— U = (S Ã— U) âˆ© (T Ã— U)

Theorem â€œNon-empty setsâ€: S â‰  {} â‰¡ (âˆƒ x â€¢ x âˆˆ S)

Theorem (14.7i): S â‰  {} â‡’ T â‰  {} â‡’ S Ã— T = T Ã— S â‡’ S = T

Theorem (14.7ii): T â‰  {} â‡’ S Ã— T = T Ã— S â‡’ S âŠ† T

Theorem (14.13): S â‰  {}  â‡’  S Ã— T âŠ† S Ã— U  â‡’  T âŠ† U
 #+end_src

** Abstract Relation Algebra: Inclusion, Composition, Converse, and Intersection :Exercise:11_1:11_2:12_2:12_3:
   :PROPERTIES:
   :CUSTOM_ID: Abstract-Relation-Algebra-Inclusion-Composition-Converse-and-Intersection
   :END:

  The type constructor ~_â†”_~ for relation types is obtained by typing ~\rel~,
  and has higher precedence than the function type constructor ~_â†’_~.

#+begin_src haskell
Declaration: _â†”_ : Type â†’ Type â†’ Type
#+end_src

*** Inclusion
    :PROPERTIES:
    :CUSTOM_ID: Inclusion
    :END:
#+begin_src haskell
Declaration: _âŠ†_ : A â†” B â†’ A â†” B â†’ ğ”¹
Axiom â€œReflexivity of âŠ†â€: R âŠ† R
Lemma â€œReflexivity of âŠ†â€: R = S  â‡’  R âŠ† S
Axiom â€œTransitivity of âŠ†â€: Q âŠ† R â‡’ R âŠ† S â‡’ Q âŠ† S
Axiom â€œAntisymmetry of âŠ†â€: R âŠ† S â‡’ S âŠ† R â‡’ R = S
Theorem â€œTransitivity of âŠ†â€: Q âŠ† R âˆ§ R âŠ† S â‡’ Q âŠ† S
Lemma â€œFlipped Transitivity of âŠ†â€: R âŠ† S â‡’ Q âŠ† R â‡’ Q âŠ† S

Theorem â€œMutual inclusionâ€: R = S  â‰¡  R âŠ† S  âˆ§ S âŠ† R
Theorem â€œIndirect Relation Equalityâ€
        â€œIndirect Relation Equality from belowâ€:
    Q = R  â‰¡  (âˆ€ S â€¢ S âŠ† Q  â‰¡  S âŠ† R)
Theorem â€œIndirect Relation Inclusionâ€
        â€œIndirect Relation Inclusion from aboveâ€:
    Q âŠ† R  â‰¡  (âˆ€ S â€¢ R âŠ† S  â‡’  Q âŠ† S)

Declaration: _âŠ‡_ : A â†” B â†’ A â†” B â†’ ğ”¹
Axiom â€œOpposite inclusionâ€: R âŠ‡ S  â‰¡  S âŠ† R
#+end_src
*** Composition
    :PROPERTIES:
    :CUSTOM_ID: Composition
    :END:
#+begin_src haskell
Declaration: _â¨¾_ : A â†” B â†’ B â†” C â†’ A â†” C
Axiom â€œAssociativity of â¨¾â€: (Q â¨¾ R) â¨¾ S = Q â¨¾ (R â¨¾ S)
Axiom â€œMonotonicity of â¨¾â€:  P âŠ† Q  â‡’  R âŠ† S  â‡’  P â¨¾ R âŠ† Q â¨¾ S
Theorem â€œMonotonicity of â¨¾â€:  Q âŠ† R  â‡’  Q â¨¾ S âŠ† R â¨¾ S
Theorem â€œMonotonicity of â¨¾â€:  R âŠ† S  â‡’  Q â¨¾ R âŠ† Q â¨¾ S

Declaration: Id : A â†” A
Axiom â€œIdentity of â¨¾â€: Id â¨¾ R = R
Axiom â€œIdentity of â¨¾â€: R â¨¾ Id = R
#+end_src
*** Converse
    :PROPERTIES:
    :CUSTOM_ID: Converse
    :END:
#+begin_src haskell
Declaration: _Ë˜ : (A â†” B) â†’ (B â†” A)
Axiom â€œSelf-inverse of Ë˜â€: R Ë˜ Ë˜  =  R
Lemma â€œCancellation of Ë˜â€:  R Ë˜ = S Ë˜  â‰¡  R = S
Axiom â€œMonotonicity of Ë˜â€: R âŠ† S      â‡’  R Ë˜ âŠ† S Ë˜
Theorem â€œIsotonicity of Ë˜â€:  R âŠ† S  â‰¡  R Ë˜ âŠ† S Ë˜
Axiom â€œConverse of `Id`â€:  Id Ë˜        =  Id
Axiom â€œConverse of â¨¾â€:     (R â¨¾ S) Ë˜    =  S Ë˜ â¨¾ R Ë˜
#+end_src
*** Intersection
    :PROPERTIES:
    :CUSTOM_ID: Intersection
    :END:
#+begin_src haskell
Declaration: _âˆ©_ : A â†” B â†’ A â†” B â†’ A â†” B

Axiom â€œCharacterisation of âˆ©â€  : Q âŠ† R âˆ© S   â‰¡   Q âŠ† R  âˆ§ Q âŠ† S

Theorem â€œWeakening for âˆ©â€      : Q âˆ© R âŠ† Q  âˆ§  Q âˆ© R âŠ† R
Theorem â€œSymmetry of âˆ©â€        : Q âˆ© R  âŠ†  R âˆ© Q
Corollary â€œSymmetry of âˆ©â€      : Q âˆ© R  =  R âˆ© Q
Theorem â€œAssociativity of âˆ©â€   : (Q âˆ© R) âˆ© S  âŠ†  Q âˆ© (R âˆ© S)
Corollary â€œAssociativity of âˆ©â€ : (Q âˆ© R) âˆ© S  =  Q âˆ© (R âˆ© S)
Theorem â€œIdempotency of âˆ©â€     : R âˆ© R = R
Theorem â€œMonotonicity of âˆ©â€    : Q âŠ† R  â‡’  Q âˆ© S âŠ† R âˆ© S

Theorem â€œInclusion via âˆ©â€      : Q âŠ† R  â‰¡  Q âˆ© R = Q

Theorem â€œConverse of âˆ©â€        :     (R âˆ© S) Ë˜  âŠ†  R Ë˜ âˆ© S Ë˜
Theorem â€œConverse of âˆ©â€        :     (R âˆ© S) Ë˜  =  R Ë˜ âˆ© S Ë˜

Theorem â€œSub-distributivity of â¨¾ over âˆ©â€:
    Q â¨¾ (R âˆ© S)  âŠ†  Q â¨¾ R  âˆ©  Q â¨¾ S
#+end_src

*** Heterogeneous Properties
    :PROPERTIES:
    :CUSTOM_ID: Heterogeneous-Properties
    :END:
#+begin_src haskell
Declaration: reflexive : A â†” A  â†’  ğ”¹
Declaration: symmetric : A â†” A  â†’  ğ”¹
Declaration: transitive, idempotent : A â†” A  â†’  ğ”¹
Declaration: equivalence, preorder : A â†” A  â†’  ğ”¹
Declaration: antisymmetric, order : A â†” A  â†’  ğ”¹

Axiom â€œDefinition of reflexivityâ€:    reflexive R      â‰¡  Id âŠ† R
Axiom â€œDefinition of symmetryâ€:       symmetric R      â‰¡  R Ë˜ âŠ† R
Axiom â€œDefinition of transitivityâ€:   transitive R     â‰¡  R â¨¾ R âŠ† R
Axiom â€œDefinition of idempotencyâ€:    idempotent R     â‰¡  R â¨¾ R = R
Axiom â€œDefinition of equivalenceâ€:    equivalence R    â‰¡  reflexive R
                                                          âˆ§ symmetric R
                                                          âˆ§ transitive R
Axiom â€œDefinition of preorderâ€:       preorder R       â‰¡  reflexive R
                                                          âˆ§ transitive R
Axiom â€œDefinition of antisymmetryâ€:   antisymmetric R  â‰¡  R âˆ© R Ë˜ âŠ† Id
Axiom â€œDefinition of orderingâ€:       order R          â‰¡  reflexive R
                                                          âˆ§ antisymmetric R
                                                          âˆ§ transitive R

Theorem â€œReflexivity of converseâ€  :    reflexive R â‰¡ reflexive (R Ë˜)
Theorem â€œReflexivity of â¨¾â€         :    reflexive R â‡’ reflexive S â‡’ reflexive (R â¨¾ S)

Lemma â€œDefinition of symmetryâ€     :    symmetric R   â‰¡   R Ë˜ = R
Theorem â€œSymmetry of converseâ€     :    symmetric R â‰¡ symmetric (R Ë˜)

Theorem â€œAntisymmetry of converseâ€ :  antisymmetric R  â‰¡  antisymmetric (R Ë˜)

Theorem â€œConverse of an orderâ€     :  order E  â‰¡  order (E Ë˜)
#+end_src
*** Dedekind and Modal Rules
    :PROPERTIES:
    :CUSTOM_ID: Dedekind-and-Modal-Rules
    :END:

#+begin_src haskell
Axiom â€œDedekind ruleâ€:    (Q â¨¾ R) âˆ© S âŠ† (Q âˆ© S â¨¾ R Ë˜) â¨¾ (R âˆ© Q Ë˜ â¨¾ S)
Theorem â€œModal ruleâ€:     (Q â¨¾ R) âˆ© S âŠ† (Q âˆ© S â¨¾ R Ë˜) â¨¾ R
Theorem â€œModal ruleâ€:     (Q â¨¾ R) âˆ© S âŠ† Q â¨¾ (R âˆ© Q Ë˜ â¨¾ S)
#+end_src

  One simple consequence of any modal rule is the following theorem (also known
  as â€œco-difunctionalityâ€); the name â€œHesitationâ€ is intended to suggest that
  whenever you can make a step forward to some place, you can also first make a
  step forward, then one back, and finally another one forward to the same place
  (due to the implicit assumption that the place you started from is still
  available for the backwards step after the first step forward).
#+begin_src haskell
Theorem â€œHesitationâ€: R âŠ† R â¨¾ R Ë˜ â¨¾ R
#+end_src

  A transitive and symmetric relations is also called a *partial equivalence relation* (PER),
  where the word â€œpartialâ€ again really just means â€œnot necessarily totalâ€,
  which in the case of PERs would be understood more naturally as â€œnot necessarily reflexiveâ€.

  This is justified by the fact that equivalence relations are total due to reflexivity.
#+begin_src haskell
Theorem â€œPER factoringâ€:    symmetric Q â‡’ transitive Q â‡’  Q â¨¾ R âˆ© Q = Q â¨¾ (R âˆ© Q)
Theorem â€œReflexive implies totalâ€:    reflexive R  â‡’  total R
Theorem â€œIdempotency from symmetric and transitiveâ€:    symmetric R â‡’ transitive R â‡’ idempotent R
#+end_src

#+begin_src haskell
Theorem â€œRight-distributivity of â¨¾ with univalent over âˆ©â€:
    univalent F  â‡’  F â¨¾ (R âˆ© S) = F â¨¾ R âˆ© F â¨¾ S

Theorem â€œSwapping mapping across âŠ†â€:
    mapping F  â‡’  (R â¨¾ F âŠ† S  â‰¡  R âŠ† S â¨¾ F Ë˜)
#+end_src

*** Powers and Reflexive-transitive Closure
    :PROPERTIES:
    :CUSTOM_ID: Powers-and-Reflexive-transitive-Closure
    :END:

#+begin_src haskell
Associating to the right: _**_
Declaration: _**_ :  (A â†” A)  â†’  â„•  â†’  (A â†” A)

Axiom â€œDefinition of **â€:  R ** 0    =  Id
Axiom â€œDefinition of **â€:  R ** suc i  =  R â¨¾ R ** i

Theorem â€œRight-identity of **â€: R ** 1 = R
Theorem â€œAddition in **â€: R ** (i + j) = R ** i â¨¾ R ** j

Declaration: _* : A â†” A  â†’  A â†” A
Axiom â€œDefinition of `_*`â€:    R * = (â‹ƒ i : â„• â€¢ R ** i)

Theorem â€œCharacterisation of `_*`: Expandingâ€:  R âŠ† R *
Theorem â€œCharacterisation of `_*`: Reflexivityâ€:  reflexive (R *)
Theorem â€œCharacterisation of `_*`: Transitivityâ€:  transitive (R *)
Theorem â€œCharacterisation of `_*`: Expansion of powersâ€:
    R âŠ† S  â‡’  reflexive S  â‡’  transitive S  â‡’ R ** i âŠ† S
Theorem â€œCharacterisation of `_*`: Minimalityâ€:
    R âŠ† S  â‡’  reflexive S  â‡’  transitive S  â‡’ R * âŠ† S
#+end_src


** Operators Combining Sets and Relations :Homework:19:
   :PROPERTIES:
   :CUSTOM_ID: Operators-Combining-Sets-and-Relations
   :END:

#+begin_src haskell
Associating to the right: _â—_ , _â©¤_
Associating to the left: _â–·_ , _â©¥_

Theorem â€œConverse of Ã—â€:  (A Ã— B) Ë˜ = B Ã— A
#+end_src
*** Domain and Range Restrictions
    :PROPERTIES:
    :CUSTOM_ID: Domain-and-Range-Restrictions
    :END:
#+begin_src haskell
  - type â€œ`\drestr`â€ for â€œ`â—`â€ --- â€œdomain restrictionâ€,
  - type â€œ`\ndrestr`â€ for â€œ`â©¤`â€ --- â€œnegated domain restrictionâ€, â€œdomain antirestrictionâ€,
  - type â€œ`\rrestr`â€ for â€œ`â–·`â€ --- â€œrange restrictionâ€,
  - type â€œ`\nrrestr`â€ for â€œ`â©¥`â€ --- â€œnegated range restrictionâ€, â€œrange antirestrictionâ€.

Declaration: _â—_ , _â©¤_ : set tâ‚ â†’ (tâ‚ â†” tâ‚‚) â†’ (tâ‚ â†” tâ‚‚)
Declaration: _â–·_ , _â©¥_ : (tâ‚ â†” tâ‚‚) â†’ set tâ‚‚ â†’ (tâ‚ â†” tâ‚‚)

Axiom â€œDefinition of â—â€:  A â— R = R âˆ© (A Ã— ğ”)
Axiom â€œDefinition of â–·â€:  R â–· B = R âˆ© (ğ” Ã— B)
Axiom â€œDefinition of â©¤â€:  A â©¤ R = R âˆ© (~ A Ã— ğ”)
Axiom â€œDefinition of â©¥â€:  R â©¥ B = R âˆ© (ğ” Ã— ~ B)

Lemma â€œDefinition of â©¤ via â—â€:   A â©¤ R  =  ~ A â— R
Lemma â€œDefinition of â©¥ via â–·â€:   R â©¥ B  =  R â–· ~ B
Theorem â€œDistributivity of â— over set intersectionâ€:  (A âˆ© B) â— R = (A â— R) âˆ© (B â— R)
Theorem â€œDistributivity of â— over relation unionâ€:    A â— (R âˆª S) = (A â— R) âˆª (A â— S)
Theorem â€œDefinition of â–· via â—â€:  R â–· B  =  (B â— R Ë˜) Ë˜
Theorem â€œDefinition of â— via â–·â€:  A â— R  =  (R Ë˜ â–· A) Ë˜
Theorem â€œDistributivity of â–· over set intersectionâ€:    R â–· (B âˆ© C) = (R â–· B) âˆ© (R â–· C)
Theorem â€œDistributivity of â–· over relation unionâ€:    (R âˆª S) â–· B = (R â–· B) âˆª (S â–· B)
Theorem â€œRange of â—â€: Ran (R â–· B) = Ran R âˆ© B
Theorem â€œRelationship via â—â€ â€œDomain restrictionâ€:    x â¦— A â— R â¦˜ y  â‰¡  x âˆˆ A âˆ§ x â¦— R â¦˜ y
Theorem â€œRelationship via â–·â€ â€œRange restrictionâ€:    x â¦— R â–· B â¦˜ y  â‰¡  x â¦— R â¦˜ y âˆˆ B
Theorem â€œRelationship via â©¤â€ â€œDomain antirestrictionâ€:    x â¦— A â©¤ R â¦˜ y  â‰¡  Â¬ (x âˆˆ A) âˆ§ x â¦— R â¦˜ y
Theorem â€œDomain restriction by `Dom`â€:  Dom S â— S = S
Theorem â€œDomain restriction via â¨¾â€:    A â— R = ğ•€ A â¨¾ R
Theorem â€œRange restriction via â¨¾â€:    R â–· B = R â¨¾ ğ•€ B
Theorem â€œSwitching â–· and â— in â¨¾â€:    (R â–· B) â¨¾ S  =  R â¨¾ (B â— S)
Theorem â€œMutual associativity of â¨¾ with â–·â€:    (R â¨¾ S) â–· C  =  R â¨¾ (S â–· C)
#+end_src
*** Relational Image
    :PROPERTIES:
    :CUSTOM_ID: Relational-Image
    :END:
#+begin_src haskell
Declaration: _â¦‡_â¦ˆ : (tâ‚ â†” tâ‚‚) â†’ set tâ‚ â†’ set tâ‚‚

Axiom â€œDefinition of â¦‡_â¦ˆâ€: R â¦‡ A â¦ˆ = Ran (A â— R)

Theorem â€œRelational imageâ€:  y âˆˆ R â¦‡ A â¦ˆ  â‰¡  (âˆƒ x â™ x âˆˆ A â€¢ x â¦— R â¦˜ y)
#+end_src
*** Relation Override
    :PROPERTIES:
    :CUSTOM_ID: Relation-Override
    :END:
#+begin_src haskell
Declaration: _âŠ•_ : (tâ‚ â†” tâ‚‚) â†’ (tâ‚ â†” tâ‚‚) â†’ (tâ‚ â†” tâ‚‚)

Axiom â€œDefinition of âŠ•â€:   R âŠ• S  =  (Dom S â©¤ R) âˆª S

Theorem â€œRelation overrideâ€:
    x â¦— R âŠ• S â¦˜ y  â‰¡  if x âˆˆ Dom S then x â¦— S â¦˜ y else x â¦— R â¦˜ y fi
#+end_src
