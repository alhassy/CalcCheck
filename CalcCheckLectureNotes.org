 # -*- eval: (my/execute-startup-blocks) -*-

#+title: Mathematics for Computing
#+subtitle: Abridged Lecture Notes @@html:<br>@@ Based on ‚ÄúA Logical Approach to Discrete Math‚Äù
#+author: Musa Al-hassy
#+options: tags:nil d:nil toc:t
#+PROPERTY: header-args:calccheck :tangle (concat (file-name-sans-extension (buffer-name)) ".calc") :comments nil

#+Description: Abridged Lecture Notes Based on ‚ÄúA Logical Approach to Discrete Math‚Äù

# Make HTML
# (f-move (org-html-export-to-html) "~/CalcCheck/LectureNotes.html")
#+HTML_HEAD: <link href="https://alhassy.github.io/org-notes-style.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://alhassy.github.io/floating-toc.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://alhassy.github.io/blog-banner.css" rel="stylesheet" type="text/css" />
# The last one has the styling for lists.

# $1 colour eg ‚Äúpink‚Äù or ‚Äúhsl(157 75% 20%)‚Äù or ‚Äú#e5f5e5‚Äù; $2 title
#+macro: begin-box @@html: <div style="padding: 1em; background-color: $1; border-radius: 15px; font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em  #00000057;"> <h3>$2</h3>@@

#+macro: end-box @@html: </div>@@

:Hide:
  {{{begin-box(teal, Salam!)}}}

  {{{end-box}}}
:End:

* Notational Setup :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Notational-Setup
  :END:
:Calc_notation:

\begin{calc}
x
\step[op]{ hint }
y
\end{calc}

:End:

#+BEGIN_export html
<style>

/* Using source blocks ‚Äúmath‚Äù as aliaas for haskell */
pre.src-math:before { content: 'Mathematical! Algebraic! Axiomatic!'; }
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell)) */

</style>
#+END_export

# The following snippet let's us export calc clauses in HTML nicely.
#+begin_latex-definitions
\def\BEGINstep{ \left\langle }
\def\ENDstep{ \right\rangle }
\newcommand{\step}[2][=]{ \\ #1 \;\; & \qquad \color{maroon}{\BEGINstep\text{ #2
} \ENDstep} \\ & }

% multi-line step with many lines of text
\newcommand{\line}[1]{ \text{#1}\hfill\\ }
\newcommand{\stepmany}[2][=]{ \\ #1 \;\; & \qquad \color{maroon}{\BEGINstep \large\substack{ #2 } \ENDstep} \\ & }

% multi-line step with 4 lines of text
\newcommand{\stepfour}[5][=]{ \stepmany[#1]{\line{#2} \line{#3} \line{#4}
\line{#5}} }

\newenvironment{calc}{\begin{align*} & }{\end{align*}}

% Inference rules
\def\And{\quad}
\newcommand\Rule[3][]{ {#2 \over #3}\mathsf{#1} }

\def\eq{\,=\,}

\def\true{\mathsf{true}}
\def\false{\mathsf{false}}

\def\even{\mathsf{even}}
#+end_latex-definitions

#+html: <p style="display:none">
$$\newcommand\exp[1]{\mathsf{exp}_{#1}\,}$$
#+html: </p>


# This snippet let's us, in an org file, do C-c C-x C-l to see the calculation
# rendered prettily. It will not work if you do #+begin_calc ‚Ä¶ #+end_calc.
#+begin_src emacs-lisp :exports none
(add-to-list 'org-latex-packages-alist
  '("fleqn, leqno, block" "calculation" t))

(setq org-format-latex-header
      (concat org-format-latex-header
              "\\usepackage{color}
               \\def\\BEGINstep{ \\langle }
               \\def\\ENDstep{ \\rangle }
               \\newcommand{\\step}[2][=]{ \\\\ #1 \\;\\; & \\qquad \\color{maroon}{\\BEGINstep \\text{ #2 } \\ENDstep} \\\\ & }
               \\newenvironment{calc}{\\begin{align*} & }{\\end{align*}}"))
#+end_src

#+RESULTS:
#+begin_example
\documentclass{article}
\usepackage[usenames]{color}
[PACKAGES]
[DEFAULT-PACKAGES]
\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-3cm}
\setlength{\oddsidemargin}{1.5cm}
\addtolength{\oddsidemargin}{-2.54cm}
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-\headheight}
\addtolength{\textheight}{-\headsep}
\addtolength{\textheight}{-\footskip}
\addtolength{\textheight}{-3cm}
\setlength{\topmargin}{1.5cm}
\addtolength{\topmargin}{-2.54cm}\usepackage{color}
               \def\BEGINstep{ \langle }
               \def\ENDstep{ \rangle }
               \newcommand{\step}[2][=]{ \\ #1 \;\; & \qquad \color{maroon}{\BEGINstep \text{ #2 } \ENDstep} \\ & }
               \newenvironment{calc}{\begin{align*} & }{\end{align*}}
#+end_example

:hide:
 \begin{calc}
  x
\step{nice}
  y
\end{calc}
:end:

* subtle colours :ignore:
  :PROPERTIES:
  :CUSTOM_ID: subtle-colours
  :END:

#+name: startup-code
#+begin_src emacs-lisp  :exports none
(defun subtle-colors (c)
  "Names are very rough approximates.

   Translations from: https://www.december.com/html/spec/softhues.html"
  (pcase c
    ("teal"    "#99FFCC") ;; close to aqua
    ("brown"   "#CCCC99") ;; close to moss
    ("gray"    "#CCCCCC")
    ("purple"  "#CCCCFF")
    ("lime"    "#CCFF99") ;; brighter than ‚Äògreen‚Äô
    ("green"   "#CCFFCC")
    ("blue"    "#CCFFFF")
    ("orange"  "#FFCC99")
    ("peach"   "#FFCCCC")
    ("pink"    "#FFCCFF")
    ("yellow"  "#FFFF99")
    ("custard" "#FFFFCC") ;; paler than ‚Äòyellow‚Äô
    (c c)
  ))
#+end_src

# $1 colour eg ‚Äúpink‚Äù or ‚Äúhsl(157 75% 20%)‚Äù or ‚Äú#e5f5e5‚Äù; $2 title
#+macro: begin-box (eval (concat "@@html: <div style=\"padding: 1em; background-color: " (subtle-colors $1) "; border-radius: 15px; font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em  #00000057;\"> <h3>" $2 "</h3>@@"))

#+macro: end-box @@html: </div>@@

:Hide:
‚ÄúSubtle colours‚Äù
#+begin_parallelNB

   {{{begin-box(teal,    This is ‚Äúteal‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(brown,   This is ‚Äúbrown‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(gray,    This is ‚Äúgray‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(purple,  This is ‚Äúpurple‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(lime,    This is ‚Äúlime‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(green,   This is ‚Äúgreen‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(blue,    This is ‚Äúblue‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(orange,  This is ‚Äúorange‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(peach,   This is ‚Äúpeach‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(pink,    This is ‚Äúpink‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(yellow,  This is ‚Äúyellow‚Äù!)}}} {{{end-box}}} \\
   {{{begin-box(custard, This is ‚Äúcustard‚Äù!)}}} {{{end-box}}} \\

#+end_parallelNB
:End:
* Introduction to Calculational Reasoning
  :PROPERTIES:
  :CUSTOM_ID: Introduction-to-Calculational-Reasoning
  :END:
** What are Calculational Proofs
   :PROPERTIES:
   :CUSTOM_ID:
   :END:

 We advocate *calculational proofs* in which reasoning is goal directed and
 justified by simple axiomatic laws that can be checked syntactically rather
 than semantically. ---/Program Construction/ by Roland Backhouse

 For example, below are two arguments showing that $\sqrt[n]{k}$ is a rational
 number precisely when $k$ is a so-called perfect /n/-th root ---consequently,
 since 2 is not a perfect square, $\sqrt{2}$ is not rational.

{{{begin-box(#e5f5e5, Classical Proof: Non-perfect powers have irrational
roots)}}}

Suppose that $k$ is not a perfect /n/-th power ---i.e., not of the form /ùìç‚Åø/---
then there is some prime $p$ in the factorisation of $k$ that has its exponent,
say $\exp{p} k$, being not a multiple of $n$.  But if $\sqrt[n]{k} \eq
a/b$ then $\exp{p}{k} \eq \exp{p}{a^n} - \exp{p}{b ^ n} \eq n ¬∑ \exp{p}{a} - n ¬∑
\exp{p}{b}$ and the difference of multiples of $n$ is a multiple of $n$, and so
we have a contradiction. Hence, no such $a, b$ could exist and so $\sqrt[n]{k}$
is irrational.
{{{end-box}}}

This is an example of an *informal proof*, which is a mixture of natural language,
English, and mathematical calculations.  The English text outline the main steps
of the proof, and the mathematical calculations fill in *some* of the details.

Since they only communicate the key ideas, such proofs are preferred by writers
but they place a large semantic burden on readers who are expected to have such
a good understanding of the problem domain that the details of the outline
proofs can be filled in, and so the writer leaves these as an implicit exercise
to the reader.

However, even worse, such informal outline proofs may skip over important
details and thus can be wrong!

Below is a *calculational proof*. It introduces notation and recalls theorems as
needed, thereby making each step of the argument easy to verify and follow.  As
such, the following argument is more accessible to readers unfamiliar with the
problem domain.

{{{begin-box(#e5f5e5, Calculational Proof)}}}

 \begin{calc}
 \def\BEGINstep{\left[} \def\ENDstep{\right.}
 \sqrt[n]{k} \text{ is a rational number }
 \stepfour{ A rational number is the fraction of two integers.}{
          Let variables $a,\, b$ range over integer numbers.}{}{
  }
  ‚àÉ\, a, b ‚Ä¢\; \sqrt[n]{k} = {a \over b}
 \step{ Use arithmetic to eliminate the $n$-th root operator.
  }
  ‚àÉ\, a, b ‚Ä¢\; k ¬∑ a ^n = b ^n
  \stepmany{ \line{Let $\exp{m} x$ be the number of times that $m$ divides $x$.}
   \line{For example, $\exp{2} 48 \eq 4$ and $\exp{2} 49 \eq 0$.}
   \line{The numbers $p$ with $‚àÄ m : ‚Ñ§‚Å∫ \,‚Ä¢\, \exp{m}p \,‚â†\, 0 \,‚â°\, m \,=\, p$ are called $prime$ numbers.}
   \line{Let variable $p$ ranges over primes numbers. }
   \line{Fundamental theorem of arithmetic: Numbers are determined by their prime powers.}
   \line{That is, $\big(‚àÄ \,p\, ‚Ä¢\; \exp{p} x \eq f(p)\big) \;‚â°\; x \,=\, \big(Œ†\, p\, ‚Ä¢\; p^{f(p)}\big)$ for any $f$.}
   \line{As such, every number is the product of its prime powers:}
   \line{$\qquad x \eq \big(Œ† \,p\, ‚Ä¢\; p^{\exp{p} x}\big)$. }
   \line{And so, any two numbers are the same precisely when they have the same primes:}
   \line{$\qquad x \eq y \;‚â°\; \big(‚àÄ p \,‚Ä¢\, \exp{p} x \eq \exp{p} y\big)$.}
  }
  ‚àÉ\, a, b ‚Ä¢\; ‚àÄ\, p ‚Ä¢\; \exp{p}(k ¬∑ a ^n) \eq \exp{p}(b ^n )
  \stepmany{\line{When $p$ is prime, $\exp{p}(x ¬∑ y) \eq \exp{p} x \,+\, \exp{p} y$.}
   \line{Aside: In general, $\exp{p}(Œ† \,i\, \,‚Ä¢\, x_i) \eq (Œ£ \,i\, \,‚Ä¢\, \exp{p} x_i)$.}
  }
  ‚àÉ\, a, b ‚Ä¢\; ‚àÄ\, p ‚Ä¢\; \exp{p} k + n ¬∑ \exp{p} a \eq n ¬∑ \exp{p} b
  \step{ Use arithmetic to collect similar terms.
  }
  ‚àÉ\, a, b ‚Ä¢\; ‚àÄ\, p ‚Ä¢\; \exp{p} k \eq  n ¬∑ \Big(\exp{p} b - \exp{p} a\Big)
  \stepmany{ \line{(‚áí) is the definition of multiplicity;}
             \line{(‚áê) take $a \,‚âî\, 1$ and define $b$ by its prime powers:}
             \line{ $\qquad ‚àÄ\, p \,‚Ä¢\, \exp{p} b \,‚âî\, {\exp{p} k \,/\, n}$}
  }
  ‚àÄ\, p ‚Ä¢\; \exp{p} k \text{ is a multiple of } n
  \step{ Fundamental theorem of arithmetic and definition of ‚Äòperfect‚Äô }
  k \text{ is a perfect $n$-th power; i.e., of the shape } x^n
\end{calc}

{{{end-box}}}

# Go back to the ‚ü®hint notation‚ü©.
#+begin_latex-definitions
\def\BEGINstep{ \left\langle }
\def\ENDstep{ \right\rangle }
#+end_latex-definitions

Finally, observe that the calculational form is *more general*.  The use of a
/formal/ approach let us keep track of when our statements are equivalent
(‚Äú=‚Äù) rather than being weakened (‚Äú‚áí‚Äù).

The above proof is a generalisation of a proof in Backhouse's text for square
roots, which may be viewed as a [[https://youtu.be/t39wHoFHbvY][Youtube video]] which makes use of kbd:CalcCheck
[[https://alhassy.github.io/CalcCheck/Docs][‚á≠]]: A proof checker for the logic of ‚ÄúA Logical Approach to Discrete Math‚Äù
(‚ÄòLADM‚Äô).
    - It /checks/ your arguments in a notation similar to that of the book.
    - *You can check your work before handing it in.*
    - You can formalise your own theorems from other books and check them
      ---unlimited exercises!

    #+begin_center
    kbd:Control_+_Alt_+_Enter to check a cell.
    #+end_center

     Going forward, instead of defining expressions by how they are evaluated,
     we define expressions in terms of how they can be manipulated.
     # operational versues aximatic method.

     A *<<<calculus>>>* is a method or process of reasoning by calculation with
     symbols.
     A Boolean variable that can denote a proposition is sometimes called a
     /propositional variable/.
     A *<<<propositional calculus>>>* is so named beacuse it is a method
     of calculating with expressions that involve propositional variables.

  {{{begin-box(pink, The propositional calculus of LADM is called ‚Äúequational
  logic ùë¨‚Äù)}}}
     One part of ùë¨ is a set of /axioms/, which are certain Boolean expressions
     that define basic manipulative properties of Boolean operators.
     For example, the axiom $p ‚à® q ‚â° q ‚à® p$ indicates (semantically)
     that the value of a disjunction doesn't depend on the order of its arguments
     and (syntactically) we may swap their order when manipulating expressions.
     The other part of this calculus are the 3 inference rules Substitution,
     Leibniz, and Transitivity.

     A *<<<theorem>>>* of this calculus is either an axiom, the conclusion
     of an inference rule whose premises are theorems, or a Boolean expression
     that, using the inference rules, is proved equal to an axiom or a previously
     proved theorem.
  {{{end-box}}}


** What is Discrete Mathematics
   :PROPERTIES:
   :CUSTOM_ID: Discrete-Mathematics
   :END:
 1. *Discrete Mathematics*
    includes logic (calculational reasoning), (data) sets, functions, relations,
    graphs, inductive types, and more.

    Conscious and fluent use of the language of (discrete) mathematics
    is the foundation for precise specification and rigorous reasoning
    in Computer Science and Software Engineering

 2. *Goal*: Understand the mechanics of mathematical expressions and proof.

 3. <<<Propositional>>>: Statements that can be either /true/ or /false/; not numbers.

    <<<Predicate>>>: Propositional statement about some subjects.

 4. <<<Calculus>>>: Formalised reasoning through calculation.

    ‚ÄòHand wavy‚Äô English arguments tend to favour /case analysis/
       ---considering what could happen in each possible scenario---
       which increases exponentially with each variable; in contrast,
       equality-based calculation is much simpler since it delegates
       intricate case analysis into codifed algebraic laws.

       E.g., Portia's Suitor's Dilemma has 4 unknowns, each being either true or false,
       and so has $2^4$ many possible scenarios to consider. Whereas a
       calculation solving the problem can be formed in less than 10 super simple
       lines.

       #+begin_details
       :title: Portia's Suitor's Dilemma

 Portia has a gold casket and a silver casket and has placed a picture of herself
 in one of them. On the caskets, she has written the following inscriptions:

 + Gold ::  The portrait is not in here
 + Silver :: Exactly one of these inscriptions is true.

 Portia explains to her suitor that each inscription may be true or false, but
 that she has placed her portrait in one of the caskets in a manner that is
 consistent with the truth or falsity of the inscriptions.

 If the suitor can choose the casket with her portrait, she will marry him.

 -----

 ( This is a ‚Äòteaser‚Äô; you're not expected to know the details in the following
 calculation. )

 Formalisation is the first step towards solution!

 #+begin_src calccheck
Declaration: G, S : ùîπ

Explanation: G ‚âî ‚ÄúThe inscription on the gold casket is true‚Äù
Explanation: S ‚âî ‚ÄúThe inscription on the silver casket is true‚Äù
 #+end_src

 ‚Ä¶ and
 #+begin_src calccheck
Declaration: gc : ùîπ
Explanation: gc ‚âî ‚ÄúThe portrait is in the gold casket‚Äù
 #+end_src

‚Ä¶ we know the portrait is in a casket preciely when
that casket's inscription is true ‚Ä¶

 #+begin_src calccheck
Axiom ‚ÄúInscription on gold casket‚Äù: G ‚â° ¬¨ gc
Axiom ‚ÄúInscription on silver casket‚Äù: S ‚â° (S ‚â° ¬¨ G)
 #+end_src

 ‚Ä¶ let us start from what we know about the silver casket:
 #+begin_src calccheck
Calculation:
    S ‚â° (S ‚â° ¬¨ G)    ‚Äî This is ‚ÄúInscription on silver casket‚Äù
  ‚â°‚ü® ‚ÄúReflexivity of ‚â°‚Äù ‚ü©
    S ‚â° S ‚â° ¬¨ G
  ‚â°‚ü® ‚ÄúSymmetry of ‚â°‚Äù ‚ü©
    ¬¨ G
  ‚â°‚ü® ‚ÄúInscription on gold casket‚Äù ‚ü©
    ¬¨ ¬¨ gc
  ‚â°‚ü® ‚ÄúDouble negation‚Äù ‚ü©
    gc
 #+end_src

 By just *simplifying*, we calculated that the portrait is in the gold casket!

 # See below [[#shape-of-calculations][The Shape of Calculations]] for more on /exploratory calculations/.

 #+end_details

 #+begin_quote
/Knowledge is software for your brain: The more you know, the more problems you
can solve!/
 #+end_quote

# Time for an upgrade!

** Road-map
   :PROPERTIES:
   :CUSTOM_ID: Road-map
   :END:

 In the previous section, we showed how a calculational argument is more structured
 and may be more accessible. Before getting to *using* such a style, we first pause
 to discuss the *foundations* that legitimatise it as a tool of reasoning.

 In general, proofs are evidence of truth of a claim; by demonstrating that the
 claim follows from some /obvious truth/ using rules of reasoning that /obviously
 preserve truth/. Here are some examples of /clearly obviously true things/.

 | Axiom       | ‚Äúself-evident (obvious) truth‚Äù                |
 |-------------+-----------------------------------------------|
 | Reflexivity | $X = X$ ---Everything is the same as itself   |
 | Symmetry    | $X = Y$ precisely when $Y = X$ ---Sameness is mutual  |

 #+caption: An inference rule is a syntactic mechansim for deriving ‚Äútruths‚Äù or ‚Äútheorems‚Äù.
 | Infernece Rule | ‚Äúa reasonable way to derive truths‚Äù                                                            |
 |----------------+------------------------------------------------------------------------------------------------|
 | Substitution   | If $E(\vec x)$ is true, then so is $E(\vec F)$ ---where $E(\vec R)$ means $E[\vec x ‚âî \vec R]$   |
 |                | E.g., Since $x + y = y + 3$ is true, so is $b + 3 = 3 + b$ ---using $x, y ‚âî b, 3$              |
 |----------------+------------------------------------------------------------------------------------------------|
 | Transitivity   | If $X = Y$ and $Y = Z$ then $X = Z$                                                            |
 |                | E.g., since $e^{i ¬∑ œÄ} = -1$ and $-1 = i¬≤$, we must have $e^{i ¬∑ œÄ} = i¬≤$.                     |
 |----------------+------------------------------------------------------------------------------------------------|
 | Leibniz        | If $X = Y$ then $E(X) = E(Y)$ ---‚Äúsubstituting equals for equals‚Äù                              |
 |                | E.g., since $n = 2 ¬∑ m$ we must have $\even n = \even (2 ¬∑ m)$                                 |
 |                | E.g., if /Jim = James/ then /Jim's home address = James' home address/.                            |
 |                |                                                                                                |

 That's a lot of hand-waving; and a few examples don't scale. In order to discuss
 proof, we need to discuss inference rules, which are ways to derive new claims
 from old claims, and so we need to discuss how claims ---expressions or
 formulae--- are written. So let's start at expressions.

   {{{begin-box(teal, Super terse definition ---to be explained in subsequent
    sections)}}}
    A /logic/ is a set of /symbols/ along with a set of /formulas/ formed from the
    symbols, and a set of /infernece rules/ which allow formulas to be derived
    from other formulas. (The formulas may or may not include a notion of variable.)
    Logics are purely syntactic objects.

    # | Syntax    | Proof theory |
    # | Semantics | Model theory |
   {{{end-box}}}

* Expressions
  :PROPERTIES:
  :CUSTOM_ID: hi
  :END:

** Precedence
   :PROPERTIES:
   :CUSTOM_ID: Precedence
   :END:
# Dot guide
# https://www.graphviz.org/pdf/dotguide.pdf

#+begin_center
How do you ‚Äòread‚Äô (/parse/) the expression $6 - x + 7$?
#+end_center

#+BEGIN_SRC dot :file images/6-x+7_third_time.png :exports results
digraph structs {
 main [shape=plaintext, label="6 - x + 7"];
 main -> parse1 [style = dashed, label = "means"];
 main -> or [style = invis];
 main -> parse2 [style = dashed, label = "means"];

 parse1 [shape=record,label="+ |{{-|{6|x}}| 7}"];
 or[shape=plaintext];
 parse2 [shape=record,label="- |{6 | {+|{x|7}}}"];

 "???"[shape=plaintext];
  or  -> "???" [style = invis];

}
#     5: struct3 [shape=record,label="hello\nworld |{ b |{c|<here> d|e}| f}| g | h"];
#+END_SRC

#+RESULTS:
[[file:images/6-x+7_third_time.png]]


It can be generated from its parts in two different ways:
1. Both $6$ and $x + 7$ are expressions, so $6 - x + 7$ is an expression.
   #+BEGIN_SRC dot :file images/6-x+7_parse2.png :exports results
   digraph structs {
    "-" -> 6;
    "-" -> "+";
    "+" -> x;
    "+" -> 7;
   }
   #+END_SRC

   #+RESULTS:
   [[file:images/6-x+7_parse2.png]]

2. and also both $6 - x$ and $7$ are expressions, so $6 - x + 7$ is an expression.
   #+BEGIN_SRC dot :file images/6-x+7_parse1.png :exports results :results replace
digraph {
 "-" -> 6;
 "-" -> x;
 "+" -> 7;
 "+" -> "-";
}
#+END_SRC

A *convention* on how a /string/ should be parsed
as a /tree/ is known as a *precedence rule*.

** Grammars
   :PROPERTIES:
   :CUSTOM_ID: Grammars
   :END:

    Expressions are defined by the following /grammar/, but /in practice/ one does
    not write $+(1, 2)$ and instead writes $1 + 2$.  However, the phrase $+(1,
    ¬∑(2, 3))$ is /unambiguous/, whereas the phrase $1 + 2 ¬∑ 3$ /could be read/ as
    $(1 + 2) ¬∑ 3$ or as $1 + (2 ¬∑ 3)$.

    #+begin_quote
    The grammar defines expressions as *abstract syntax (trees)* whereas strings
    with mixfix notation gives a *concrete syntax* where ambiguity is resolved by
    parentheses, precedence, or association rules.
    #+end_quote
    # Parentheses, precedences, and association rules only serve to disambiguate
    # the encoding of trees in strings.

    #+begin_src math
Expr ::= Constant    -- E.g., 1 or ‚Äúapple‚Äù
      |  Variable    -- E.g., x or apple (no quotes!)
      |  Application -- E.g., f(x‚ÇÅ, x‚ÇÇ, ‚Ä¶, x‚Çô)
    #+end_src

    ( One reads =:== as /becomes/ and so the addition of an extra
    colon results in a ‚Äòstutter‚Äô: One reads
     =::== as /be-becomes/. The symbol =|= is read /or/. )

  {{{begin-box(teal)}}}
Notice that a /constant/ is really just an /application/ with $n = 0$ arguments
and so the first line in the definition above could be omitted.
  {{{end-box}}}

** Textual Substitution ---i.e., [[https://en.wikipedia.org/wiki/Grafting][‚Äúgrafting trees‚Äù]]
   :PROPERTIES:
   :CUSTOM_ID: Textual-Substitution-i-e-https-en-wikipedia-org-wiki-Grafting-grafting-trees
   :END:

  The *(simultaneous textual) Substitution operation* $E[\vec x ‚âî \vec F]$
  replaces all variables $\vec x$ with parenthesised expressions $\vec F$ in an
  expression $E$. In particular, $E[x ‚âî F]$ is just $E$ but with all
  occurrences of $x$ replaced by $‚Äú(F)‚Äù$. This is the ‚Äúfind-and-replace‚Äù utility
  you use on your computers.

 {{{begin-box(lime)}}}
  Textual substitution on expressions is known as ‚Äúgrafting‚Äù on trees: Evaluate
  $E[x ‚âî F]$ by going down the tree $E$ and finding all the ‚Äòleaves‚Äô labelled
  $x$, cut them out and replace them with the new trees $F$.
 {{{end-box}}}

 {{{begin-box(teal)}}}
  Using the informal English definition of substitution, one quickly notices
  $E[x ‚âî x] = E$ and $E[x ‚âî y][y ‚âî x] = E$.
 {{{end-box}}}

  Since expressions are either variables of functions applications,
  substitution can be defined by the following two clauses ---we will get to
  recursion and induction more formally later on.
  \begin{align*}
     y[x ‚âî F]              &=  \mathsf{if}\, x = y \,\mathsf{then}\, F \,\mathsf{else}\, y \,\mathsf{fi}\,
  \\ f(t‚ÇÅ, ‚Ä¶, t‚Çô)[x ‚âî F]  &=  f(t‚ÇÅ‚Ä≤, ‚Ä¶, t‚Çô‚Ä≤) \; \text{ where } t·µ¢‚Ä≤ = t·µ¢[x ‚âî F]
  \end{align*}

  {{{begin-box(teal, Sequential ‚â† Simultaneous)}}}
  \[
  (x + 2 ¬∑ y)[x ‚âî y][y ‚âî x]  \quad‚â†\quad  (x + 2 ¬∑ y)[x, y ‚âî y, x]
  \]
  {{{end-box}}}

  [[https://alhassy.github.io/PythonCheatSheet/CheatSheet.pdf][Python]], for example, has simultaneous /assignment/; e.g., ~x, y = y, x~ is
  used to swap the value of two variables.

  Within CalcCheck, to simplify and actually perform the substitution, one uses
  the hint kbd:Substitution; e.g.,
  #+begin_src calccheck
  (x + 2 ¬∑ y)[x, y ‚âî 3 ¬∑ y, x + 5]
=‚ü® Substitution ‚ü©
   3 ¬∑ y + 2 ¬∑ (x + 5)
  #+end_src

** ‚ÄúMeta-ùí≥‚Äù: Speaking about the concept of ùí≥ using the notions of ùí≥
   :PROPERTIES:
   :CUSTOM_ID: Meta-ùí≥-Speaking-about-the-concept-of-ùí≥-using-the-notions-of-ùí≥
   :END:

    When we write phrases like =‚ÄúLet E be an expression‚Äù=, then the /name/ $E$
    varies and so is a variable, but it is an expression and so may consist of a
    function application or a variable. *That is, $E$ is a variable that may
    stand for variables.* This layered inception is resolved by referring to $E$
    as not just any normal variable, but instead as a *meta-variable*: A variable
    capable of referring to other (simpler) variables.

    Aside: A *variable of type œÑ* is a /name/ denoting a yet unknown /value/ of type œÑ;
    i.e., ‚Äúit is a pronoun (nickname) referring to a person in the collection of people œÑ‚Äù.
    E.g., to say $x$ is an integer variable means that we may treat it
    as if it were a number whose precise value is unknown.
    Then, if we let =Expr œÑ= refer to the expressions denoting /values/ of type œÑ;
    then a *meta-variable* is simply a normal variable of type =Expr œÑ=.

    Likewise, a *theorem* is a Boolean expression that is proved equal to an axiom;
    whereas a *meta-theorem* is a general statement about our logic that we prove
    to be true. That is, if ùë¨ is collection of rules that allows us to find
    truths, then a /theorem/ is a truth found using those rules; whereas a
    /meta-theorem/ is property of ùë¨ itself, such as what theorems it can have.
    That is, theorems are _in_ ùë¨ and meta-theorems are _about_ ùë¨.  For example, here
    is a meta-theorem that the equational logic ùë¨ has (as do many other theories,
    such as lattices): An /equational/ theorem is true precisely when its ‚Äòdual‚Äô is
    true. Such metatheorems can be helpful to discover new theorems.
    # A meta-theorem is a theorem about theorems.
    #
    # E.g., p ‚àß q ‚áí q is not an equation, but it is equivalent to the equation
    # p ‚àß q ‚áí p ‚â° true, whose dual is p ‚à® q ‚áç q ‚â° false; i.e.,
    # p ‚à® q ‚áê q.

    #+caption: Being self-reflective using ‚Äúmeta‚Äù (Greek for ‚Äòbeyond‚Äô)
    | meta-ùí≥           | ‚Äúthe study of ùí≥‚Äù or ‚Äúùí≥ about ùí≥‚Äù or ‚Äúbeyond ùí≥‚Äù         |
    |------------------+-------------------------------------------------------|
    | meta-joke        | a joke about jokes                                    |
    | meta-data        | data about data; e.g., publication date               |
    | meta-fiction     | a fictional story that acknowledges itself as fiction |
    | meta-game        | a game in which mini-games happen; e.g., Mario Party  |
    | meta-cognition   | thinking about thinking                               |
    | meta-ethics      | what is the ethical way to study ethics               |
    | meta-physics     | the study of that which is beyond the physical        |
    | meta-mathematics | studying systems of reasoning; aka ‚Äòproof theory‚Äô     |

* Logics
  :PROPERTIES:
  :CUSTOM_ID: Logics
  :END:
** Syntax vs. Semantics
   :PROPERTIES:
   :CUSTOM_ID: Syntax-vs-Semantics
   :END:

   *Syntax* refers to the structure of expressions, or the rules for putting
     symbols together to form an expression. *Semantics* refers to the meaning
     of expressions or how they are evaluated.

   An expression can contain variables, and evaluating such an expression
   requires knowing what values to use for these variables; i.e., a *state*:
   A list of variables with associated values. E.g., evaluation of $x - y + 2$ in
   the state consisting of $(x, 5)$ and $(y, 6)$ is performed by replacing $x$
   and $y$  by their values to yield $5 - 6 + 2$ and then evaluating that to
   yield $1$.

   A Boolean expression $P$ is *<<<satisfied>>>* in a state if its value is /true/
   in that state; $P$ is *<<<satisfiable>>>* if there is a state in which it is
   satisfied; and $P$ is *<<<valid>>>* (or is a *<<<tautology>>>*) if it is
   satisfied in every state.

 --------------------------------------------------------------------------------

     All theorems of the propositional calculus ùë¨ are valid. This can be checked by checking
     that each axiom with a truth table and arguing for each inference rule that
     if its premises are valid then so is its conclusion.

     For example, let's show that the Substitution rule preserves validity.  Let
     us write $s(E)$ to denote the value of expression $E$ in state $s$.  If $E$
     is valid, then it is true in any state, let's argue that $E[x ‚âî F]$ is also
     true in any state. So, given a state $s$, let $s‚Ä≤$ be the ‚Äòupdated‚Äô state
     that assigns the same values to all the variables as does $s$ /except/ that
     the variable $x$ is assigned the value $s(F)$.  Then, since $E$ is valid,
     $s‚Ä≤(E)$ is true but $s‚Ä≤(E)$ is just $s\big(E[x ‚âî F]\big)$ and so the
     resulting substitution is also valid.

     In programming, if we want the /assignment/ $x ‚âî F$ to ensure a property $R$
     holds, then we need $R[x ‚âî F]$ to hold /before/ the assignment.
     That is, if the state $s$ of our program variables satisfies $R[x ‚âî F]$
     then the updated state $s‚Ä≤$ ---having /s‚Ä≤(x) = s(F)/--- will satisfy $R$.

     Not only are all theorems valid, but all valid expressions are theorems of
     our calculus (although we do not prove this fact). Theoremhood and validity
     are one and the same.

 --------------------------------------------------------------------------------

   Evaluation of the expression $X = Y$ in a state yields the value /true/ if
   expressions $X$ and $Y$ have the same value and yields /false/ if they have
   different values.

   This characterisation of equality is in terms of expression evaluation.

   For reasoning about expressions, a more useful characterisation
   would be a set of laws that can be used to show that two expressions
   are equal, *without* calculating their values.
   # c.f., static analysis versues running a program

   For example, you know that $x = y$ equals $y = x$, regardless
   of the values of $x$ and $y$.

   A collection of such laws can be regarded as a definition
   of equality, *provided* two expressions have the same value
   in all states precisely when one expression can be translated into
   the other according to the laws.

   Later we see that theorems correspond to expressions that are true in all states.

** Inference Rules
   :PROPERTIES:
   :CUSTOM_ID: Logics-and-Inference-Rules
   :END:

   Formally, a ‚Äúproof‚Äù is obtained by applying a number of ‚Äúrules‚Äù to known
   results to obtain new results; a ‚Äútheorem‚Äù is the conclusion of a ‚Äúproof‚Äù.
   An ‚Äúaxiom‚Äù is a rule that does not need to be applied to any existing
   results: It's just a known result.

   That is, a *rule* $R$ is a tuple $P‚ÇÅ, ‚Ä¶, P‚Çô, C$ that is thought of as ‚Äòtaking
   *premises* (instances of known results) $P·µ¢$‚Äô and acting as a ‚Äònatural,
   reasonable justification‚Äô to obtain *conclusion* $C$.  A *proof system* is a
   collection of rules. At first sight, this all sounds very abstract and rather
   useless, however it is a /game/: *Starting from rules, what can you obtain?* Some
   games can be very fun! Another way to see these ideas is from the view of
   programming:

   #+caption: Proofs-are-programs
   | /           | <                                     |
   | Mathematics | Programming                           |
   |-------------+---------------------------------------|
   | logic       | trees (algebraic data types, ùí≤-types) |
   | rules       | constructors                          |
   |-------------+---------------------------------------|
   | proof       | an application of constructors        |
   | axiom       | a constructor with no arguments       |

   For example, recall from elementary school that the addition ‚Äò+‚Äô
   of a number 12 and a number 7 to obtain a number 19 is written as
   \begin{align*}
    & 12 \\
   + & \;\;7 \\ \hline
    & 19
   \end{align*}
   This familiar notation is also used for proof rules as well:
   A rule $R = (P‚ÇÅ, ‚Ä¶, P‚Çô, C)$ is traditionally presented in the shape
   \[{P‚ÇÅ \; P‚ÇÇ \; ‚Ä¶ \; P‚Çô \over C}R\]

   {{{begin-box(lime, ùë∞ùë≠ I have ingredients and a recipe for a cake ùëªùëØùë¨ùëµ I can
   make a cake)}}}

   Here are two familiar and eerily similar rules ;-)

   $$\Rule[Function Application]{a : A \And f : A ‚Üí B}{f(a) : B}$$

   $$\Rule[Modus Ponens]{p \And p ‚áí q}{q}$$

   For instance, the first rule says ‚Äúif you have a road between two cities, /A/ and /B/, then you
   can travel from address /a/ in city /A/ to get to address /f(a)/ in city $B$‚Äù.  The
   second rule says the same thing, but *forgets/ignores* the precise
   locations. Sometimes it's okay for something ‚Äúto exist‚Äù, but other times
   that's not enough and you ‚Äúactually want to get (construct) it somehow‚Äù;
   e.g., as the title begs: It's /possible/ to make a cake, but /how/? /Which/ recipe
   you use makes a difference!

   # The second rule is also known as /Impication Elimination/
   # as it is ‚Äúthe way an implication can be used‚Äù.

   {{{end-box}}}

 --------------------------------------------------------------------------------

     Just as there are meta-variables and meta-theorems, there is ‚Äòmeta-syntax‚Äô:
     - The use of a fraction to delimit premises from conclusion is a form of ‚Äòimplication‚Äô.
     - The use of a comma, or white space, to separate premises is a form of ‚Äòconjunction‚Äô.

     If our expressions actually have an implication and conjunction operation,
     then inference rules $\Rule[R]{P‚ÇÅ \And ‚ãØ \And P‚Çô}{C}$ can be presented as
     axioms $P‚ÇÅ \,‚àß\, ‚ãØ \,‚àß\, P‚Çô \,‚áí\, C$.

     The inference rule says ‚Äúif the $P·µ¢$ are all valid, i.e., true in /all
     states/, then so is $C$‚Äù; the axiom, on the other hand, says ‚Äúif the $P·µ¢$
     are true in /a state/, then $C$ is true in /that state/.‚Äù Thus the rule and
     the axiom are not quite the same.

     Moreover, the rule is not a Boolean expression.
     Rules are thus more general, allowing us to construct
     systems of reasoning that have no concrete notions of ‚Äòtruth‚Äô ---recall, the
     water buckets probelm (above/below?).

     Finally, the rule asserts that $C$ follows from $P‚ÇÅ, ‚Ä¶, P‚Çô$.
     The formula $P‚ÇÅ \,‚àß\, ‚ãØ \,‚àß\, P‚Çô \,‚áí\, C$, on the other hand, is a Boolean
     expression (but it need not be a theorem).

 --------------------------------------------------------------------------------

   Let's look at a few simpler rules; the next 3 rules
   are part of the *Logic E* system used in the LADM text book
   ---see ‚Äú[[http://www.cse.yorku.ca/~logicE/misc/logicE_intro.pdf][Equational Propositional Logic]]‚Äù by Gries & Schneider.

** Rules of Equality and Proof Trees vs. Calculational Proofs
   :PROPERTIES:
   :CUSTOM_ID: Rules-of-Equality-Proof-Trees-and-Calculations
   :END:

 # ** Defining equality by how it can be used, manipulated


 # E.g., 4 laws that characterise equality are reflexitivitry, symmetry,
 #   transitvity, and Leibniz.

 Before we can showcase an example of a proof tree ---let alone
 compare them with calculational proofs--- we need a few
 example inference rules that can be used in the construction of the proofs.

 The following rules define equality by how it can be used, manipulated.

 1. Equality is:
    - *reflexive:* $X = Y$;
    - *symmetric:* $X = Y$ implies $Y = X$; and
    - *transitive*: $X = Z$ follows from having both $X = Y$ and $Y = Z$, for any
      $Y$

 2. The *Substitution inference rule*
    says that a substitution $E[\vec x ‚âî \vec F]$ is
    a theorem /whenever/ $E$ is a theorem.

    Within CalcCheck, this rule is realised as the kbd:with clause: The phrase =E
    with `x‚ÇÅ, x‚ÇÇ, ‚Ä¶, x‚Çô ‚âî F‚ÇÅ, F‚ÇÇ, ‚Ä¶, F‚Çô`= is tantamount to invoking the theorem
    $E[\vec x ‚âî \vec F]$. The rule is applied /implicitly/, unless =rigid matching=
    is activated ---e.g., to get students *thinking correctly about applying
    theorems* instead of just putting random theorems that look similar and hoping
    the system sees a justification from a mixture of them.

 3. The *Leibniz inference rule* says that $E[z ‚âî X] = E[z ‚âî Y]$ whenever $X = Y$;
    i.e., it justifies substituting ‚Äúequals for equals‚Äù.

    Leibniz allows us to use an equation to rewrite a part of an expression; and
    so, it justifies the use of ‚Äòcalculation hints‚Äô.

    Leibniz says: Two expressions are equal (in all states) precisely when
    replacing one by the other in any expression $E$ does not change the value of
    $E$ (in any state).

      {{{begin-box(blue)}}}
    A /function/ $f$ is a rule for computing a value from another value.

    If we define $f\, x = E$ using an expression, then /function application/ can
    be defined using textual substitution: $f \, X = E[x ‚âî X]$. That is,
    expressions can be considered functions of their variables
    ---but it is still expressions that are the primitive idea, the building blocks.

    Using functions, Leibniz says /if X = Y then f X = f Y, for any function f/.
    That is, if two things are actually the same, then any (/f-/)value extracted
    from one must be the same when extracted from the other.
    {{{end-box}}}

    Again: Unlike the Substitution rule, which allows us to instantiate /any/
    theorem, the Leibniz rule is meant for *applying equational theorems deeper
    within expressions*. Later on, we will look at ‚Äòmonotonicity rules‚Äô which will
    let us apply inclusion (‚â§, ‚áí, ‚äë) theorems deep within expressions.

    The kbd:with syntax is overloaded for this rule as well.

 ------

 In addition to these rules, suppose that we have
    $2 ¬∑ a = a + a$ (‚ÄúTwice‚Äù) and $-1 ¬∑ a = - a$ (15.20) as axioms;
    then we can form the following proof.

 \[
 \Rule[Transitivity\; of\; =]
 {\large
   \Rule[\small Substitution]
   {\Large \Rule{‚úì}{-1 ¬∑ a \,=\, - a} }
   { (- 1) ¬∑ 2 ¬∑ (x + y) \,=\, - (2 ¬∑ (x + y)) }
   \And
   \Rule[\small Leibniz]
   {\Large \Rule{‚úì}{2 ¬∑ a = a + a} }
   { - (2 ¬∑ (x + y)) \,=\,    -((x + y) + (x + y)) }
 }{(- 1) ¬∑ 2 ¬∑ (x + y) \,=\, -((x + y) + (x + y))}
 \]

 This is known as a /natural deduction proof tree/; one begins ‚Äòreading‚Äô such a
 proof from the very *bottom*: Each line is an application of a rule of reasoning,
 whose assumptions are above the line; so read upward.
 The *benefit* of this approach is that *rules guide proof construction*; i.e., it is
 goal-directed.

 However the *downsides are numerous*:
 - So much horizontal space for such a simple proof!
 - One has to *repeat* common subexpressions, such as the
   $-(2 ¬∑ (x + y))$.
 - For comparison with other proof notations, such as Hilbert style,
   see ‚Äú[[http://www.cse.yorku.ca/~logicE/misc/logicE_intro.pdf][Equational Propositional Logic]]‚Äù or LADM-¬ß6.

 Instead, we may use a more ‚Äòlinear‚Äô proof format:
 \begin{calc}
 (- 1) ¬∑ 2 ¬∑ (x + y)
 \step{ 15.20) $- a \,=\, - 1 ¬∑ a$
       ‚îÄ Using implicit substitution rule }
 - (2 ¬∑ (x + y))
 \step{ ‚ÄúTwice‚Äù
       ‚îÄ Using implicit Leibniz with $a ‚âî x + y$ }
 -((x + y) + (x + y))
 \end{calc}

 In this equational style, instead of a *tree* (on the left)
 we use a *sequential chain of equalities* (on the right):

 #+begin_parallel org
 $$\Rule[Leibniz]{X \,=\, Y}{E[z ‚âî X] \,=\, E[z ‚âî Y]}$$

 #+html: <br>

 \begin{calc}
     E[z ‚âî X]
 \step{ X = Y }
     E[z ‚âî Y]
 \end{calc}
 #+end_parallel

 In this way, we may use the Substitution rule to create theorems that can be
 used with the Leibniz rule and then use the Transitivity rule to conclude
 that the first expression of an equational proof is equivalent to the last one.
 {{{begin-box(orange, )}}}
 To show that $L = R$, transform $L$ into $R$ by a series of substitutions
 of equals for equals. (If $R$ has more ‚Äòstructure‚Äô, then begin at $R$ and
 transform to $L$.)
 {{{end-box}}}

 --------------------------------------------------------------------------------

 + Transitivity allows us to conclude the first expression in a calculation
    is equal to the last expression in the calculation.
 + Reflexivity allows us to have ‚Äòempty‚Äô calculations and ‚Äúno (expression) change‚Äù
      calculation steps
 + Symmetry allows us to use an equation $LHS = RHS$
      ‚Äúin the other direction‚Äù to replace an instance of $RHS$ by $LHS$.

 Equational proofs thus have this shape:

 \begin{calc}
   P
 \step{ $P = Q[z ‚âî X]$ }
   Q[z ‚âî X]
 \stepmany{ \line{make a ‚Äúremark‚Äù about $Q[z ‚âî X]$}
            \line{or the direction of the proof}
            \line{or ‚Äúremove superflous parentheses‚Äù}
            \line{or ‚Äúinsert parentheses for clairty‚Äù} }
   Q[z ‚âî X]
 \step{ $X = Y$ }
   Q[z ‚âî Y]
 \step{ $R = Q[z ‚âî Y]$ ‚îÄ‚îÄnote the change in ‚Äòdirection‚Äô }
   R
 \end{calc}

 Which is far *easier to read and write* than:
 \[
 \Rule[Transitivity]{
  P = Q[z ‚âî X]
  \And
  \Rule[Transitivity]{
    \Rule[\large Transitivity]{ \LARGE
      \Rule[Reflexivity]{}{Q[z ‚âî X] \eq Q[z ‚âî X]}
      \And
      \Rule[Leibniz]{X \eq Y}{Q[z ‚âî X] \eq Q[z ‚âî Y]}
      }{\LARGE Q[z ‚âî X] \eq Q[z ‚âî Y]}
    \And
    {\LARGE \Rule[\large Symmetry]{R \eq Q[z ‚âî Y]}{Q[z ‚âî Y] \eq R}
    }}
 {\large \text{$Q[z ‚âî X] \eq R$}}}
 {P = R}
 \]

    *The structure of equational proofs allows implicit use of infernece rules
    Leibniz, Transitvitity & Symmetry & Reflexivity of equality, and Substitution.* In contrast, the
    structure of proof trees is no help in this regard, and so all uses of
    inference rules must be mentioned explicitly.
    # In fact, more suitable inference rules for proof trees are those of /natural
    # deduction/ (ùëµùë´): Each propositional operator ‚äï has two rules, one to show
    # how to introduce it into a theorem (i.e., prove a theorem involving it) and
    # one to show how to use it (eliminate it) to derive new truths; as such, ùëµùë´
    # has no axioms and the ‚áí-elimination inference rule is known as ‚Äúmodus
    # ponens‚Äù, a theorem in ùë¨.

 --------------------------------------------------------------------------------

    Leibniz is often used with Substitution, as follows
    ---supposing we know the theorem =‚ÄúHalf‚Äù= $2 ¬∑ x / 2 = x$:

    \begin{calc}
      2 ¬∑ j / 2 = 2 ¬∑ (j - 1)
    \step{ Half, with $x ‚âî j$ }
      j = 2 ¬∑ (j - 1)
    \end{calc}

    We are using Leibniz with the premise $2 ¬∑ j / 2 = j$.
    We can use this premise only if it is a theorem. It is, because
    $2 ¬∑ x / 2 = x$ is a theorem and, therefore, by Substitution,
    $(2 ¬∑ x / 2 = x)[x ‚âî j]$ is a theorem.

    If a use of Substitution is simple enough, as in this case, we may leave
    off the indication ‚Äúwith $x ‚âî j$‚Äù.

* Boolean Expressions and Laws
  :PROPERTIES:
  :CUSTOM_ID: Boolean-Expressions-and-Laws
  :END:

 The type of propositions is known as the *Booleans* and denoted ùîπ.
    #+begin_src math
ùîπ ::= true | false
    #+end_src

** Equality: ‚Äú=‚Äù and ‚Äú‚â°‚Äù
   :PROPERTIES:
   :CUSTOM_ID: Equality-and
   :END:

   For instance, the notion of equality on any type œÑ is
   typed ~_=_ : œÑ ‚Üí œÑ ‚Üí ùîπ~; i.e., equality takes two values of a type œÑ
   and returns a propositional value.

   #+begin_quote
   In general, the ‚Äúcontinued equality‚Äù $x = y = z$
   is *read conjunctively*: Both $x = y$ /and/ $y = z$.
   However, for the special case œÑ being ùîπ, the expression
   $x = y = z$ could be *read associativity*: $(x = y) = z$.

   These two ways to read (parse) a continued equality
   give different operators on ùîπ. The associative equality
   is popularly written as ‚Äò‚áî‚Äô but, unfortunately, not usually treated
   as an equality at all! In this class, we write the associative equality
   as ‚Äò‚â°‚Äô and read it as ‚Äúequivales‚Äù.

   See [[https://www.researchgate.net/publication/220113201_The_associativity_of_equivalence_and_the_Towers_of_Hanoi_problem][The associativity of equivalence and the Towers of Hanoi problem]].
   #+end_quote

The phrase $p ‚â° q$ may be read as
   - /p is equivalent to q/, or
   - /p exactly when q/,
   - /p if-and-only-if q/,

   This operator is just equality on the Booleans:
   | Definition of ‚â° |   | ~(p ‚â° q) = (p = q)~ |

   The need for a new name for an existing concept is that they have different
   *notational conventions*: Firstly, ‚Äú‚â°‚Äù has lower precedence than ‚Äú=‚Äù and
   secondly,
   - = is conjunctive :: $\big(p = q = r\big) \quad=\quad \big( (p = q)
     \;\land\; (q = r)\big)$
   - ‚â° is associative :: $\big(p ‚â° q ‚â° r\big) \quad=\quad \big((p ‚â° q) ‚â° r\big) \quad=\quad \big(p ‚â° (q ‚â° r)\big)$

   For example, $\false ‚â° \true ‚â° \false$ is $\true$, whereas
   $\false = \true = \false$ is $\false$.

** Useful Operators
   :PROPERTIES:
   :CUSTOM_ID: Useful-Operators
   :END:
The Booleans have a number of useful operators that model reasoning,
   such as:
   #+caption: Boolean operators and similar numeric operators
   | Operator    | Booleans (ùîπ)    | Numbers (‚Ñ§)                 |
   | /           | >               |                             |
   |-------------+-----------------+-----------------------------|
   | ‚Äúand‚Äù       | =_‚àß_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúminimum‚Äù =_‚Üì_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§=   |
   | ‚Äúor‚Äù        | =_‚à®_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúmaximum‚Äù =_‚Üë_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§=   |
   | ‚Äúnot‚Äù       | =¬¨_ : ùîπ ‚Üí ùîπ=      | ‚Äúnegation‚Äù =-_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§=   |
   | ‚Äúimplies‚Äù   | =_‚áí_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúinclusion‚Äù =_‚â§_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ùîπ= |
   | [[https://www.researchgate.net/publication/220113201_The_associativity_of_equivalence_and_the_Towers_of_Hanoi_problem][‚ÄúEquivales‚Äù]]  | =_‚â°_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúequality‚Äù =_=_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ùîπ=  |

   These operators can be defined /informally/, as done below, but we shall follow
   an /axiomatic/ definition as done in LADM by providing an /interface/ of
   properties that they satisfy instead of any particular /implementation/. Later
   in the class when we get to the =if_then_else_fi= construct, we may provide
   explicit implementations and prove them to be equal to the operations
   specified axiomatically.

   #+caption: Example explicit definitions ---not used in this class
   | ‚Äúp ‚àß q‚Äù is ‚Äútrue‚Äù whenever both ‚Äúp‚Äù and ‚Äúq‚Äù are ‚Äútrue‚Äù, otherwise it is ‚Äúfalse‚Äù |
   | ‚Äúm ‚Üì n‚Äù is ‚Äúm‚Äù whenever ‚Äúm ‚â§ n‚Äù, otherwise it is ‚Äún‚Äù                            |

** Boolean Laws and Numeric Laws
   :PROPERTIES:
   :CUSTOM_ID: Boolean-Laws-and-Numeric-Laws
   :END:
To better understand the ùîπooleans, it can be useful to compare their laws
    with those on numbers. For instance, the =Definition of ‚áí= at first glance is
    tremendously cryptic: Why in the world would anyone define implication in
    this way $p ‚áí q \,‚â°\, p ‚àß q ‚â° p$?  However, when compared to the similar law
    for numbers that defines inclusion $m ‚â§ n \,‚â°\, m ‚Üì n = m$, the definition
    becomes *‚Äúobvious‚Äù*: /p is included in (implies) q precisely when having both p
    and q is the same as just having p/; i.e., /m is at-most n precisely when m is
    the minimum of m and n./

    #+caption: Properties of propositional operators and similar (familiar) numeric laws
    | Law                  | Booleans (ùîπ)                      | Numbers (‚Ñ§ with ¬±‚àû)               |
    | /                    | >                                 |                                   |
    |----------------------+-----------------------------------+-----------------------------------|
    | Symmetry of ‚àß        | $p ‚àß q ‚â° q ‚àß p$                   | $m ‚Üì n = n ‚Üì m$                   |
    | Associativity of ‚àß   | $(p ‚àß q) ‚àß r ‚â° p ‚àß (q ‚àß r)$       | $m ‚Üì n = n ‚Üì m$                   |
    | Idempotency of ‚àß     | $p ‚àß p ‚â° p$                       | $n ‚Üì n = n$                       |
    | Identity of ‚àß        | $p ‚àß \true ‚â° p$                   | $n ‚Üì +‚àû = n$                      |
    | Zero of ‚àß            | $p ‚àß \false ‚â° \false$             | $n ‚Üì -‚àû = -‚àû$                     |
    | Contradiction        | $p ‚àß ¬¨ p ‚â° \false$                | ‚îÄnope‚îÄ                            |
    |----------------------+-----------------------------------+-----------------------------------|
    | Symmetry of ‚à®        | $p ‚à® q ‚â° q ‚à® p$                   | $m ‚Üë n = n ‚Üë m$                   |
    | Associativity of ‚à®   | $(p ‚à® q) ‚à® r ‚â° p ‚à® (q ‚à® r)$       | $m ‚Üë n = n ‚Üë m$                   |
    | Idempotency of ‚à®     | $p ‚à® p ‚â° p$                       | $n ‚Üë n = n$                       |
    | Identity of ‚à®        | $p ‚à® \false ‚â° p$                  | $n ‚Üë -‚àû = n$                      |
    | Zero of ‚à®            | $p ‚à® \true ‚â° p$                   | $n ‚Üë +‚àû = +‚àû$                     |
    | Excluded Middle      | $p ‚à® ¬¨ p ‚â° \false$                | ‚îÄnope‚îÄ                            |
    |----------------------+-----------------------------------+-----------------------------------|
    | Golden Rule          | $p ‚àß q ‚â° p ‚â° q ‚â° p ‚à® q$           | $m ‚Üì n = m \,‚â°\, n = m ‚Üë n$       |
    | ‚àß/‚à® Distributivity   | $p ‚àß (q ‚à® r) ‚â° (p ‚àß q) ‚à® (p ‚àß r)$ | $m ‚Üë (n ‚Üì r) = (m ‚Üë n) ‚Üì (m ‚Üë r)$ |
    | ‚à®/‚àß Distributivity   | $p ‚à® (q ‚àß r) ‚â° (p ‚à® q) ‚àß (p ‚à® r)$ | $m ‚Üë (n ‚Üì r) = (m ‚Üë n) ‚Üì (m ‚Üë r)$ |
    |----------------------+-----------------------------------+-----------------------------------|
    | Double negation      | $¬¨ ¬¨ p ‚â° p$                       | $- - n = n$                       |
    | Definition of $\false$ | $\false ‚â° ¬¨ \true$                | $-‚àû \,=\, - (+‚àû)$                 |
    | Negation of $\false$ | $¬¨ \false = \true$                | $- (-‚àû) = +‚àû$                     |
    | De Morgan            | $¬¨(p ‚àß q) = ¬¨ p ‚à® ¬¨ q$            | $-(m ‚Üì n) = -m ‚Üë -n$              |
    |                      | $¬¨(p ‚à® q) = ¬¨ p ‚àß ¬¨ q$            | $-(m ‚Üë n) = -m ‚Üì -n$              |
    |----------------------+-----------------------------------+-----------------------------------|
    | Definition of ‚áí      | $p ‚áí q ‚â° p ‚àß q ‚â° p$               | $m ‚â§ n \,‚â°\, m ‚Üì n = m$           |
    |                      | $p ‚áí q ‚â° p ‚à® q ‚â° q$               | $m ‚â§ n \,‚â°\, m ‚Üë n = n$           |
    | Consequence          | $p ‚áê q ‚â° q ‚áí p$                   | $m ‚â• n \,‚â°\, n ‚â§ m$               |
    | ex falso quodlibet   | $\false ‚áí p ‚â° \true$              | $-‚àû ‚â§ n \,‚â°\, \true$              |
    | Left-identity of ‚áí   | $\true ‚áí p ‚â° p$                   | $+‚àû ‚â§ n \,‚â°\, n = +‚àû$             |
    | Right-zero of ‚áí      | $p ‚áí \true ‚â° \true$               | $n ‚â§ +‚àû \,‚â°\, \true$              |
    | Definition of ¬¨      | $p ‚áí \false ‚â° ¬¨ p$                | ‚îÄnope‚îÄ                            |
    |----------------------+-----------------------------------+-----------------------------------|
* TODO COMMENT Quantification and Predicate Logic
  :PROPERTIES:
  :CUSTOM_ID: Quantification-and-Predicate-Logic
  :END:
* TODO COMMENT Sets
  :PROPERTIES:
  :CUSTOM_ID: Sets
  :END:
* TODO COMMENT Relations and Functions
  :PROPERTIES:
  :CUSTOM_ID: Relations-and-Functions
  :END:
* TODO COMMENT Induction and Sequences
  :PROPERTIES:
  :CUSTOM_ID: Induction-and-Sequences
  :END:
* TODO COMMENT Graphs and Counting
  :PROPERTIES:
  :CUSTOM_ID: Graphs-and-Counting
  :END:
