#+title: Mathematics for Computing
#+subtitle: Abrdiged Lecture Notes
#+author: Musa Al-hassy
#+options: tags:nil d:nil toc:t
#+PROPERTY: header-args:calccheck :tangle (concat (file-name-sans-extension (buffer-name)) ".calc") :comments nil

#+Description: Abrdiged Lecture Notes

# Make HTML
# (f-move (org-html-export-to-html) "~/github_calccheck/LectureNotes.html")
#+HTML_HEAD: <link href="https://alhassy.github.io/org-notes-style.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://alhassy.github.io/floating-toc.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://alhassy.github.io/blog-banner.css" rel="stylesheet" type="text/css" />
# The last one has the styling for lists.

# $1 colour eg ‚Äúpink‚Äù or ‚Äúhsl(157 75% 20%)‚Äù or ‚Äú#e5f5e5‚Äù; $2 title
#+macro: begin-box @@html: <div style="padding: 1em; background-color: $1; border-radius: 15px; font-size: 0.9em; box-shadow: 0.05em 0.1em 5px 0.01em  #00000057;"> <h3>$2</h3>@@

#+macro: end-box @@html: </div>@@

* Notational Setup :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Notational-Setup
  :END:
:Calc_notation:

\begin{calc}
x
\step[op]{ hint }
y
\end{calc}

:End:

#+BEGIN_export html
<style>

/* Using source blocks ‚Äúmath‚Äù as aliaas for haskell */
pre.src-math:before { content: 'Mathematical! Algebraic! Axiomatic!'; }
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell)) */

</style>
#+END_export

# The following snippet let's us export calc clauses in HTML nicely.
#+begin_latex-definitions
\def\BEGINstep{ \left\langle }
\def\ENDstep{ \right\rangle }
\newcommand{\step}[2][=]{ \\ #1 \;\; & \qquad \color{maroon}{\BEGINstep\text{ #2
} \ENDstep} \\ & }

% multi-line step with many lines of text
\newcommand{\line}[1]{ \text{#1}\hfill\\ }
\newcommand{\stepmany}[2][=]{ \\ #1 \;\; & \qquad \color{maroon}{\BEGINstep \large\substack{ #2 } \ENDstep} \\ & }

% multi-line step with 4 lines of text
\newcommand{\stepfour}[5][=]{ \stepmany[#1]{\line{#2} \line{#3} \line{#4} \line{#5}} }


\newenvironment{calc}{\begin{align*} & }{\end{align*}}

\def\eq{\,=\,}

\def\true{\mathsf{true}}
\def\false{\mathsf{false}}
#+end_latex-definitions

#+html: <p style="display:none">
$$\newcommand\exp[1]{\mathsf{exp}_{#1}\,}$$
#+html: </p>


# This snippet let's us, in an org file, do C-c C-x C-l to see the calculation
# rendered prettily. It will not work if you do #+begin_calc ‚Ä¶ #+end_calc.
#+begin_src emacs-lisp :exports none
(add-to-list 'org-latex-packages-alist
  '("fleqn, leqno, block" "calculation" t))

(setq org-format-latex-header
      (concat org-format-latex-header
              "\\usepackage{color}
               \\def\\BEGINstep{ \\langle }
               \\def\\ENDstep{ \\rangle }
               \\newcommand{\\step}[2][=]{ \\\\ #1 \\;\\; & \\qquad \\color{maroon}{\\BEGINstep \\text{ #2 } \\ENDstep} \\\\ & }
               \\newenvironment{calc}{\\begin{align*} & }{\\end{align*}}"))
#+end_src

#+RESULTS:
#+begin_example
\documentclass{article}
\usepackage[usenames]{color}
[PACKAGES]
[DEFAULT-PACKAGES]
\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-3cm}
\setlength{\oddsidemargin}{1.5cm}
\addtolength{\oddsidemargin}{-2.54cm}
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-\headheight}
\addtolength{\textheight}{-\headsep}
\addtolength{\textheight}{-\footskip}
\addtolength{\textheight}{-3cm}
\setlength{\topmargin}{1.5cm}
\addtolength{\topmargin}{-2.54cm}\usepackage{color}
               \def\BEGINstep{ \langle }
               \def\ENDstep{ \rangle }
               \newcommand{\step}[2][=]{ \\ #1 \;\; & \qquad \color{maroon}{\BEGINstep \text{ #2 } \ENDstep} \\ & }
               \newenvironment{calc}{\begin{align*} & }{\end{align*}}
#+end_example

:hide:
 \begin{calc}
  x
\step{nice}
  y
\end{calc}
:end:

* Introduction to Calculational Reasoning :Lecture_1:
  :PROPERTIES:
  :CUSTOM_ID: Introduction-to-Calculational-Reasoning
  :END:
** What are Calculational Proofs
   :PROPERTIES:
   :CUSTOM_ID:
   :END:

 We advocate *calculational proofs* in which reasoning is goal directed and
 justified by simple axiomatic laws that can be checked syntactically rather
 than semantically. ---/Program Construction/ by Roland Backhouse

 For example, below are two arguments showing that $\sqrt[n]{k}$ is a rational
 number precisely when $k$ is a so-called perfect /n/-th root ---consequently,
 since 2 is not a perfect square, $\sqrt{2}$ is not rational.

{{{begin-box(#e5f5e5, Classical Proof: Non-perfect powers have irrational
roots)}}}

Suppose that $k$ is not a perfect /n/-th power ---i.e., not of the form /ùìç‚Åø/---
then there is some prime $p$ in the factorisation of $k$ that has its exponent,
say $\exp{p} k$, being not a multiple of $n$.  But if $\sqrt[n]{k} \eq
a/b$ then $\exp{p}{k} \eq \exp{p}{a^n} - \exp{p}{b ^ n} \eq n ¬∑ \exp{p}{a} - n ¬∑
\exp{p}{b}$ and the difference of multiples of $n$ is a multiple of $n$, and so
we have a contradiction. Hence, no such $a, b$ could exist and so $\sqrt[n]{k}$
is irrational.
{{{end-box}}}

This is an example of an *informal proof*, which is a mixture of natural language,
English, and mathematical calculations.  The English text outline the main steps
of the proof, and the mathematical calculations fill in *some* of the details.

Since they only communicate the key ideas, such proofs are preferred by writers
but they place a large semantic burden on readers who are expected to have such
a good understanding of the problem domain that the details of the outline
proofs can be filled in, and so the writer leaves these as an implicit exercise
to the reader.

However, even worse, such informal outline proofs may skip over important
details and thus can be wrong!

Below is a *calculational proof*. It introduces notation and recalls theorems as
needed, thereby making each step of the argument easy to verify and follow.  As
such, the following argument is more accessible to readers unfamiliar with the
problem domain.

{{{begin-box(#e5f5e5, Calculational Proof)}}}

 \begin{calc}
 \def\BEGINstep{\left[} \def\ENDstep{\right.}
 \sqrt[n]{k} \text{ is a rational number }
 \stepfour{ A rational number is the fraction of two integers.}{
          Let variables $a,\, b$ range over integer numbers.}{}{
  }
  ‚àÉ\, a, b ‚Ä¢\; \sqrt[n]{k} = {a \over b}
 \step{ Use arithmetic to eliminate the $n$-th root operator.
  }
  ‚àÉ\, a, b ‚Ä¢\; k ¬∑ a ^n = b ^n
  \stepmany{ \line{Let $\exp{m} x$ be the number of times that $m$ divides $x$.}
   \line{For example, $\exp{2} 48 \eq 4$ and $\exp{2} 49 \eq 0$.}
   \line{The numbers $p$ with $‚àÄ m : ‚Ñ§‚Å∫ \,‚Ä¢\, \exp{m}p \,‚â†\, 0 \,‚â°\, m \,=\, p$ are called $prime$ numbers.}
   \line{Let variable $p$ ranges over primes numbers. }
   \line{Fundamental theorem of arithmetic: Numbers are determined by their prime powers.}
   \line{That is, $\big(‚àÄ \,p\, ‚Ä¢\; \exp{p} x \eq f(p)\big) \;‚â°\; x \,=\, \big(Œ†\, p\, ‚Ä¢\; p^{f(p)}\big)$ for any $f$.}
   \line{As such, every number is the product of its prime powers:}
   \line{$\qquad x \eq \big(Œ† \,p\, ‚Ä¢\; p^{\exp{p} x}\big)$. }
   \line{And so, any two numbers are the same precisely when they have the same primes:}
   \line{$\qquad x \eq y \;‚â°\; \big(‚àÄ p \,‚Ä¢\, \exp{p} x \eq \exp{p} y\big)$.}
  }
  ‚àÉ\, a, b ‚Ä¢\; ‚àÄ\, p ‚Ä¢\; \exp{p}(k ¬∑ a ^n) \eq \exp{p}(b ^n )
  \stepmany{\line{When $p$ is prime, $\exp{p}(x ¬∑ y) \eq \exp{p} x \,+\, \exp{p} y$.}
   \line{Aside: In general, $\exp{p}(Œ† \,i\, \,‚Ä¢\, x_i) \eq (Œ£ \,i\, \,‚Ä¢\, \exp{p} x_i)$.}
  }
  ‚àÉ\, a, b ‚Ä¢\; ‚àÄ\, p ‚Ä¢\; \exp{p} k + n ¬∑ \exp{p} a \eq n ¬∑ \exp{p} b
  \step{ Use arithmetic to collect similar terms.
  }
  ‚àÉ\, a, b ‚Ä¢\; ‚àÄ\, p ‚Ä¢\; \exp{p} k \eq  n ¬∑ \Big(\exp{p} b - \exp{p} a\Big)
  \stepmany{ \line{(‚áí) is the definition of multiplicity;}
             \line{(‚áê) take $a \,‚âî\, 1$ and define $b$ by its prime powers:}
             \line{ $\qquad ‚àÄ\, p \,‚Ä¢\, \exp{p} b \,‚âî\, {\exp{p} k \,/\, n}$}
  }
  ‚àÄ\, p ‚Ä¢\; \exp{p} k \text{ is a multiple of } n
  \step{ Fundamental theorem of arithmetic and definition of ‚Äòperfect‚Äô }
  k \text{ is a perfect $n$-th power; i.e., of the shape } x^n
\end{calc}

{{{end-box}}}

Finally, observe that the calculational form is *more general*.  The use of a
/formal/ approach let us keep track of when our statements are equivalent
(‚Äú=‚Äù) rather than being weakened (‚Äú‚áí‚Äù).

The above proof is a generalisation of a proof in Backhouse's text for square
roots, which may be viewed as a [[https://youtu.be/t39wHoFHbvY][Youtube video]] which makes use of kbd:CalcCheck
[[https://alhassy.github.io/CalcCheck/Docs][‚á≠]]: A proof checker for the logic of ‚ÄúA Logical Approach to Discrete Math‚Äù
(‚ÄòLADM‚Äô).
    - It /checks/ your arguments in a notation similar to that of the book.
    - *You can check your work before handing it in.*
    - You can formalise your own theorems from other books and check them
      ---unlimited exercises!

    #+begin_center
    kbd:Control_+_Alt_+_Enter to check a cell.
    #+end_center

** What is Discrete Mathematics
   :PROPERTIES:
   :CUSTOM_ID: Discrete-Mathematics
   :END:
 1. *Discrete Mathematics*
    includes logic (calculational reasoning), (data) sets, functions, relations,
    graphs, inductive types, and more.

    Conscious and fluent use of the language of (discrete) mathematics
    is the foundation for precise specification and rigorous reasoning
    in Computer Science and Software Engineering

 2. *Goal*: Understand the mechanics of mathematical expressions and proof.

 3. <<<Propositional>>>: Statements that can be either /true/ or /false/; not numbers.

    <<<Predicate>>>: Propositional statement about some subjects.

 4. <<<Calculus>>>: Formalised reasoning through calculation.

    ‚ÄòHand wavy‚Äô English arguments tend to favour /case analysis/
       ---considering what could happen in each possible scenario---
       which increases exponentially with each variable; in contrast,
       equality-based calculation is much simpler since it delegates
       intricate case analysis into codifed algebraic laws.

       E.g., Portia's Suitor's Dilemma has 4 unknowns, each being either true or false,
       and so has $2^4$ many possible scenarios to consider. Whereas a
       calculation solving the problem can be formed in less than 10 super simple
       lines.

       #+begin_details
       :title: Portia's Suitor's Dilemma

 Portia has a gold casket and a silver casket and has placed a picture of herself
 in one of them. On the caskets, she has written the following inscriptions:

 + Gold ::  The portrait is not in here
 + Silver :: Exactly one of these inscriptions is true.

 Portia explains to her suitor that each inscription may be true or false, but
 that she has placed her portrait in one of the caskets in a manner that is
 consistent with the truth or falsity of the inscriptions.

 If the suitor can choose the casket with her portrait, she will marry him.

 -----

 ( This is a ‚Äòteaser‚Äô; you're not expected to know the details in the following
 calculation. )

 Formalisation is the first step towards solution!

 #+begin_src calccheck
Declaration: G, S : ùîπ

Explanation: G ‚âî ‚ÄúThe inscription on the gold casket is true‚Äù
Explanation: S ‚âî ‚ÄúThe inscription on the silver casket is true‚Äù
 #+end_src

 ‚Ä¶ and
 #+begin_src calccheck
Declaration: gc : ùîπ
Explanation: gc ‚âî ‚ÄúThe portrait is in the gold casket‚Äù
 #+end_src

‚Ä¶ we know the portrait is in a casket preciely when
that casket's inscription is true ‚Ä¶

 #+begin_src calccheck
Axiom ‚ÄúInscription on gold casket‚Äù: G ‚â° ¬¨ gc
Axiom ‚ÄúInscription on silver casket‚Äù: S ‚â° (S ‚â° ¬¨ G)
 #+end_src

 ‚Ä¶ let us start from what we know about the silver casket:
 #+begin_src calccheck
Calculation:
    S ‚â° (S ‚â° ¬¨ G)    ‚Äî This is ‚ÄúInscription on silver casket‚Äù
  ‚â°‚ü® ‚ÄúReflexivity of ‚â°‚Äù ‚ü©
    S ‚â° S ‚â° ¬¨ G
  ‚â°‚ü® ‚ÄúSymmetry of ‚â°‚Äù ‚ü©
    ¬¨ G
  ‚â°‚ü® ‚ÄúInscription on gold casket‚Äù ‚ü©
    ¬¨ ¬¨ gc
  ‚â°‚ü® ‚ÄúDouble negation‚Äù ‚ü©
    gc
 #+end_src

 By just *simplifying*, we calculated that the portrait is in the gold casket!

 # See below [[#shape-of-calculations][The Shape of Calculations]] for more on /exploratory calculations/.

 #+end_details

 #+begin_quote
/Knowledge is software for your brain: The more you know, the more problems you
can solve!/
 #+end_quote

# Time for an upgrade!

* Boolean Expressions and Propositional Logic
  :PROPERTIES:
  :CUSTOM_ID: Boolean-Expressions-and-Propositional-Logic
  :END:
** Expressions                                                    :Lecture_2:
   :PROPERTIES:
   :CUSTOM_ID: hi
   :END:

# Dot guide
# https://www.graphviz.org/pdf/dotguide.pdf

#+begin_center
How do you ‚Äòread‚Äô (/parse/) the expression $6 - x + 7$?
#+end_center

#+BEGIN_SRC dot :file images/6-x+7_third_time.png :exports results
digraph structs {
 main [shape=plaintext, label="6 - x + 7"];
 main -> parse1 [style = dashed, label = "means"];
 main -> or [style = invis];
 main -> parse2 [style = dashed, label = "means"];

 parse1 [shape=record,label="+ |{{-|{6|x}}| 7}"];
 or[shape=plaintext];
 parse2 [shape=record,label="- |{6 | {+|{x|7}}}"];

 "???"[shape=plaintext];
  or  -> "???" [style = invis];

}
#     5: struct3 [shape=record,label="hello\nworld |{ b |{c|<here> d|e}| f}| g | h"];
#+END_SRC

#+RESULTS:
[[file:images/6-x+7_third_time.png]]



It can be generated from its parts in two different ways:
1. Both $6$ and $x + 7$ are expressions, so $6 - x + 7$ is an expression.
   #+BEGIN_SRC dot :file images/6-x+7_parse2.png :exports results
   digraph structs {
    "-" -> 6;
    "-" -> "+";
    "+" -> x;
    "+" -> 7;
   }
   #+END_SRC

   #+RESULTS:
   [[file:images/6-x+7_parse2.png]]

2. and also both $6 - x$ and $7$ are expressions, so $6 - x + 7$ is an expression.
   #+BEGIN_SRC dot :file images/6-x+7_parse1.png :exports results
digraph {
 "-" -> 6;
 "-" -> x;
 "+" -> 7;
 "+" -> "-";
}
#+END_SRC

#+RESULTS:
[[file:images/6-x+7_parse1.png]]

A *convention* on how a /string/ should be parsed
as a /tree/ is known as a *precedence rule*.

------

    Expressions are defined by the following /grammar/, but /in practice/ one does
    not write $+(1, 2)$ and instead writes $1 + 2$.  However, the phrase $+(1,
    ¬∑(2, 3))$ is /unambiguous/, whereas the phrase $1 + 2 ¬∑ 3$ /could be read/ as
    $(1 + 2) ¬∑ 3$ or as $1 + (2 ¬∑ 3)$.

    #+begin_quote
    The grammar defines expressions as *abstract syntax (trees)* whereas strings
    with mixfix notation gives a *concrete syntax* where ambiguity is resolved by
    parentheses, precedence, or association rules.
    #+end_quote
    # Parentheses, precedences, and association rules only serve to disambiguate
    # the encoding of trees in strings.

    #+begin_src math
Expr ::= Constant    -- E.g., 1 or ‚Äúapple‚Äù
      |  Variable    -- E.g., x or apple (no quotes!)
      |  Application -- E.g., f(x‚ÇÅ, x‚ÇÇ, ‚Ä¶, x‚Çô)
    #+end_src

    ( One reads =:== as /becomes/ and so the addition of an extra
    colon results in a ‚Äòstutter‚Äô: One reads
     =::== as /be-becomes/. The symbol =|= is read /or/. )

** Boolean Operators                                               :Lecture2:
   :PROPERTIES:
   :CUSTOM_ID: Boolean-Operators
   :END:

 The type of propositions is known as the *Booleans* and denoted ùîπ.
    #+begin_src math
ùîπ ::= true | false
    #+end_src

*** Equality: ‚Äú=‚Äù and ‚Äú‚â°‚Äù
    :PROPERTIES:
    :CUSTOM_ID: Equality-and
    :END:

    For instance, the notion of equality on any type œÑ is
    typed ~_=_ : œÑ ‚Üí œÑ ‚Üí ùîπ~; i.e., equality takes two values of a type œÑ
    and returns a propositional value.

    #+begin_quote
    In general, the ‚Äúcontinued equality‚Äù $x = y = z$
    is *read conjunctively*: Both $x = y$ /and/ $y = z$.
    However, for the special case œÑ being ùîπ, the expression
    $x = y = z$ could be *read associativity*: $(x = y) = z$.

    These two ways to read (parse) a continued equality
    give different operators on ùîπ. The associative equality
    is popularly written as ‚Äò‚áî‚Äô but, unfortunately, not usually treated
    as an equality at all! In this class, we write the associative equality
    as ‚Äò‚â°‚Äô and read it as ‚Äúequivales‚Äù.

    See [[https://www.researchgate.net/publication/220113201_The_associativity_of_equivalence_and_the_Towers_of_Hanoi_problem][The associativity of equivalence and the Towers of Hanoi problem]].
    #+end_quote

 The phrase $p ‚â° q$ may be read as
    - /p is equivalent to q/, or
    - /p exactly when q/,
    - /p if-and-only-if q/,

    This operator is just equality on the Booleans:
    | Definition of ‚â° |   | ~(p ‚â° q) = (p = q)~ |

    The need for a new name for an existing concept is that they have different
    *notational conventions*: Firstly, ‚Äú‚â°‚Äù has lower precedence than ‚Äú=‚Äù and
    secondly,
    - = is conjunctive :: $\big(p = q = r\big) \quad=\quad \big( (p = q)
      \;\land\; (q = r)\big)$
    - ‚â° is associative :: $\big(p ‚â° q ‚â° r\big) \quad=\quad \big((p ‚â° q) ‚â° r\big) \quad=\quad \big(p ‚â° (q ‚â° r)\big)$

    For example, $\false ‚â° \true ‚â° \false$ is $\true$, whereas
    $\false = \true = \false$ is $\false$.

*** Useful Operators
    :PROPERTIES:
    :CUSTOM_ID: Useful-Operators
    :END:
 The Booleans have a number of useful operators that model reasoning,
    such as:
    #+caption: Boolean operators and similar numeric operators
    | Operator    | Booleans (ùîπ)    | Numbers (‚Ñ§)                 |
    | /           | >               |                             |
    |-------------+-----------------+-----------------------------|
    | ‚Äúand‚Äù       | =_‚àß_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúminimum‚Äù =_‚Üì_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§=   |
    | ‚Äúor‚Äù        | =_‚à®_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúmaximum‚Äù =_‚Üë_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§=   |
    | ‚Äúnot‚Äù       | =¬¨_ : ùîπ ‚Üí ùîπ=      | ‚Äúnegation‚Äù =-_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ‚Ñ§=   |
    | ‚Äúimplies‚Äù   | =_‚áí_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúinclusion‚Äù =_‚â§_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ùîπ= |
    | [[https://www.researchgate.net/publication/220113201_The_associativity_of_equivalence_and_the_Towers_of_Hanoi_problem][‚ÄúEquivales‚Äù]]  | =_‚â°_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ= | ‚Äúequality‚Äù =_=_ : ‚Ñ§ ‚Üí ‚Ñ§ ‚Üí ùîπ=  |

    These operators can be defined /informally/, as done below, but we shall follow
    an /axiomatic/ definition as done in LADM by providing an /interface/ of
    properties that they satisfy instead of any particular /implementation/. Later
    in the class when we get to the =if_then_else_fi= construct, we may provide
    explicit implementations and prove them to be equal to the operations
    specified axiomatically.

    #+caption: Example explicit definitions ---not used in this class
    | ‚Äúp ‚àß q‚Äù is ‚Äútrue‚Äù whenever both ‚Äúp‚Äù and ‚Äúq‚Äù are ‚Äútrue‚Äù, otherwise it is ‚Äúfalse‚Äù |
    | ‚Äúm ‚Üì n‚Äù is ‚Äúm‚Äù whenever ‚Äúm ‚â§ n‚Äù, otherwise it is ‚Äún‚Äù                            |

*** Boolean Laws and Numeric Laws
    :PROPERTIES:
    :CUSTOM_ID: Boolean-Laws-and-Numeric-Laws
    :END:
To better understand the ùîπooleans, it can be useful to compare their laws
    with those on numbers. For instance, the =Definition of ‚áí= at first glance is
    tremendously cryptic: Why in the world would anyone define implication in
    this way $p ‚áí q \,‚â°\, p ‚àß q ‚â° p$?  However, when compared to the similar law
    for numbers that defines inclusion $m ‚â§ n \,‚â°\, m ‚Üì n = m$, the definition
    becomes *‚Äúobvious‚Äù*: /p is included in (implies) q precisely when having both p
    and q is the same as just having p/; i.e., /m is at-most n precisely when m is
    the minimum of m and n./

    #+caption: Properties of propositional operators and similar (familiar) numeric laws
    | Law                  | Booleans (ùîπ)                      | Numbers (‚Ñ§ with ¬±‚àû)               |
    | /                    | >                                 |                                   |
    |----------------------+-----------------------------------+-----------------------------------|
    | Symmetry of ‚àß        | $p ‚àß q ‚â° q ‚àß p$                   | $m ‚Üì n = n ‚Üì m$                   |
    | Associativity of ‚àß   | $(p ‚àß q) ‚àß r ‚â° p ‚àß (q ‚àß r)$       | $m ‚Üì n = n ‚Üì m$                   |
    | Idempotency of ‚àß     | $p ‚àß p ‚â° p$                       | $n ‚Üì n = n$                       |
    | Identity of ‚àß        | $p ‚àß \true ‚â° p$                   | $n ‚Üì +‚àû = n$                      |
    | Zero of ‚àß            | $p ‚àß \false ‚â° \false$             | $n ‚Üì -‚àû = -‚àû$                     |
    | Contradiction        | $p ‚àß ¬¨ p ‚â° \false$                | ‚îÄnope‚îÄ                            |
    |----------------------+-----------------------------------+-----------------------------------|
    | Symmetry of ‚à®        | $p ‚à® q ‚â° q ‚à® p$                   | $m ‚Üë n = n ‚Üë m$                   |
    | Associativity of ‚à®   | $(p ‚à® q) ‚à® r ‚â° p ‚à® (q ‚à® r)$       | $m ‚Üë n = n ‚Üë m$                   |
    | Idempotency of ‚à®     | $p ‚à® p ‚â° p$                       | $n ‚Üë n = n$                       |
    | Identity of ‚à®        | $p ‚à® \false ‚â° p$                  | $n ‚Üë -‚àû = n$                      |
    | Zero of ‚à®            | $p ‚à® \true ‚â° p$                   | $n ‚Üë +‚àû = +‚àû$                     |
    | Excluded Middle      | $p ‚à® ¬¨ p ‚â° \false$                | ‚îÄnope‚îÄ                            |
    |----------------------+-----------------------------------+-----------------------------------|
    | Golden Rule          | $p ‚àß q ‚â° p ‚â° q ‚â° p ‚à® q$           | $m ‚Üì n = m \,‚â°\, n = m ‚Üë n$       |
    | ‚àß/‚à® Distributivity   | $p ‚àß (q ‚à® r) ‚â° (p ‚àß q) ‚à® (p ‚àß r)$ | $m ‚Üë (n ‚Üì r) = (m ‚Üë n) ‚Üì (m ‚Üë r)$ |
    | ‚à®/‚àß Distributivity   | $p ‚à® (q ‚àß r) ‚â° (p ‚à® q) ‚àß (p ‚à® r)$ | $m ‚Üë (n ‚Üì r) = (m ‚Üë n) ‚Üì (m ‚Üë r)$ |
    |----------------------+-----------------------------------+-----------------------------------|
    | Double negation      | $¬¨ ¬¨ p ‚â° p$                       | $- - n = n$                       |
    | Definition of $\false$ | $\false ‚â° ¬¨ \true$                | $-‚àû \,=\, - (+‚àû)$                 |
    | Negation of $\false$ | $¬¨ \false = \true$                | $- (-‚àû) = +‚àû$                     |
    | De Morgan            | $¬¨(p ‚àß q) = ¬¨ p ‚à® ¬¨ q$            | $-(m ‚Üì n) = -m ‚Üë -n$              |
    |                      | $¬¨(p ‚à® q) = ¬¨ p ‚àß ¬¨ q$            | $-(m ‚Üë n) = -m ‚Üì -n$              |
    |----------------------+-----------------------------------+-----------------------------------|
    | Definition of ‚áí      | $p ‚áí q ‚â° p ‚àß q ‚â° p$               | $m ‚â§ n \,‚â°\, m ‚Üì n = m$           |
    |                      | $p ‚áí q ‚â° p ‚à® q ‚â° q$               | $m ‚â§ n \,‚â°\, m ‚Üë n = n$           |
    | Consequence          | $p ‚áê q ‚â° q ‚áí p$                   | $m ‚â• n \,‚â°\, n ‚â§ m$               |
    | ex falso quodlibet   | $\false ‚áí p ‚â° \true$              | $-‚àû ‚â§ n \,‚â°\, \true$              |
    | Left-identity of ‚áí   | $\true ‚áí p ‚â° p$                   | $+‚àû ‚â§ n \,‚â°\, n = +‚àû$             |
    | Right-zero of ‚áí      | $p ‚áí \true ‚â° \true$               | $n ‚â§ +‚àû \,‚â°\, \true$              |
    | Definition of ¬¨      | $p ‚áí \false ‚â° ¬¨ p$                | ‚îÄnope‚îÄ                            |
    |----------------------+-----------------------------------+-----------------------------------|

* TODO COMMENT Quantification and Predicate Logic
  :PROPERTIES:
  :CUSTOM_ID: Quantification-and-Predicate-Logic
  :END:
* TODO COMMENT Sets
  :PROPERTIES:
  :CUSTOM_ID: Sets
  :END:
* TODO COMMENT Relations and Functions
  :PROPERTIES:
  :CUSTOM_ID: Relations-and-Functions
  :END:
* TODO COMMENT Induction and Sequences
  :PROPERTIES:
  :CUSTOM_ID: Induction-and-Sequences
  :END:
* TODO COMMENT Graphs and Counting
  :PROPERTIES:
  :CUSTOM_ID: Graphs-and-Counting
  :END:
